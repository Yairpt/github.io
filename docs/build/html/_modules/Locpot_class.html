

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Locpot_class &mdash; Wave_Function_Propagation 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Wave_Function_Propagation
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Wave_Function_Propagation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>Locpot_class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for Locpot_class</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Sun Oct  3 12:11:13 2021</span>

<span class="sd">@author: Yair Reichman</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">pymatgen.io.vasp.outputs</span> <span class="kn">import</span> <span class="n">Locpot</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="kn">import</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">Lattice</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="c1"># from Find_peaks import find_peaks</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">ss</span>
<span class="kn">from</span> <span class="nn">Help_function_library_yair</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">matplotlib.widgets</span> <span class="kn">import</span> <span class="n">Cursor</span>
<span class="c1">#from lmfit import Model, Parameters, Minimizer, minimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.font_manager</span> <span class="k">as</span> <span class="nn">fm</span>

<div class="viewcode-block" id="Locpot_yair"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair">[docs]</a><span class="k">class</span> <span class="nc">Locpot_yair</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">     Class of locpot where all its properties and its methods can be found</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Locpot_yair.__init__"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_locpot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_2D</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_bulk_material</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Has_interface</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Locpot_file_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Locpot_file_directory</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Bulk_Locpot_file_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Bulk_Locpot_file_directory</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">Locpot_Full_path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Locpot_bulk_materials_full_path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">to_flip</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">has_flipped</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initiation method:</span>
<span class="sd">        ==================</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        input_locpot : pymatgen.io.vasp.outputs.Locpot, optional, default: None</span>
<span class="sd">                Can be initialized with an existing pymatgen locpot object.</span>
<span class="sd">        axis_index : int,{0: x, 1: y, 2: z}, optional, default: 2</span>
<span class="sd">                The axis index to be averaged along. (for x, insert  axis_index=0, for y axis insert axis_index=1,</span>
<span class="sd">                and for z axis insert axis_index=2).</span>
<span class="sd">        is_2D : bool, optional, default: False</span>
<span class="sd">                A flag that enables to perform 2D calculations. Not all functions support 2D calculations yet.</span>
<span class="sd">        bulk_material : bool, optional, default: False</span>
<span class="sd">                Aims to skip unecessary steps in the initializtion process for loading bulk materials.</span>
<span class="sd">        Locpot_file_name : str, optional, default: None</span>
<span class="sd">                Supply the string for the name of the locpot file, and also a string for the full path of the directory where the locpot files</span>
<span class="sd">                are located.</span>
<span class="sd">        Locpot_file_directory : str, optional, default: None</span>
<span class="sd">                Supply the string for the name of the locpot file, and also a string for the full path of the directory where the locpot files</span>
<span class="sd">                are located.</span>
<span class="sd">        Bulk_Locpot_file_name : list/tuple (str,str), optional, default: None</span>
<span class="sd">                For two different bulk locpot file names and full paths - supply it in a form of a list\tuple. The first place is for the first bulk material</span>
<span class="sd">                and the second place is for the second bulk material.</span>
<span class="sd">        Bulk_Locpot_file_directory : list/tuple (str,str), optional, default: None</span>
<span class="sd">                For two different bulk locpot file names and full paths - supply it in a form of a list\tuple. The first place is for the first bulk material</span>
<span class="sd">                and the second place is for the second bulk material.</span>
<span class="sd">        Locpot_Full_pat : str, optional, default: None</span>
<span class="sd">                Supply the string for the the full path of the Locpot file.</span>
<span class="sd">        Locpot_bulk_materials_full_path : list/tuple (str,str), optional, default: None</span>
<span class="sd">                For two different bulk locpot full paths - supply it in a form of a list\tuple. The first place is for the first bulk material</span>
<span class="sd">                and the second place is for the second bulk material.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_name</span> <span class="o">=</span> <span class="n">Locpot_file_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_flip</span> <span class="o">=</span> <span class="n">to_flip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_flipped</span> <span class="o">=</span> <span class="n">has_flipped</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_directory</span> <span class="o">=</span> <span class="n">Locpot_file_directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_name</span> <span class="o">=</span> <span class="n">Bulk_Locpot_file_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_directory</span> <span class="o">=</span> <span class="n">Bulk_Locpot_file_directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_full_path</span> <span class="o">=</span> <span class="n">Locpot_Full_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_bulk_materials_full_path</span> <span class="o">=</span> <span class="n">Locpot_bulk_materials_full_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_directory</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_full_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_full_path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span><span class="nb">str</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                <span class="n">temp_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_directory</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_name</span><span class="p">)):</span>
                    <span class="n">temp_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_directory</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Bulk_Locpot_file_name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_bulk_materials_full_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_bulk_materials_full_path</span><span class="p">)</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_bulk_materials_full_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_bulk_materials_full_path</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_bulk_materials_full_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">input_locpot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span> <span class="o">=</span> <span class="n">Locpot</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span> <span class="o">=</span> <span class="n">input_locpot</span>
        <span class="k">if</span> <span class="n">input_locpot</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_file_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Locpot_full_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You should supply an locpot object or a locpot file name and path&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">=</span> <span class="n">axis_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span> <span class="o">=</span> <span class="n">Has_interface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_2D</span> <span class="o">=</span> <span class="n">is_2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_locpot_vec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_bulk_material</span> <span class="o">=</span> <span class="n">is_bulk_material</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_locpot_bulk_materials</span><span class="p">(</span> <span class="n">bulk_material</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bulk_material</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Locpot_yair.get_atoms_position"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.get_atoms_position">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `numpy.ndarray`, (N,5)</span>
<span class="sd">                A matrix of the the coordinates of the atoms. There are 5 columns, the first three are the spatial coordinates of the atoms,</span>
<span class="sd">                as the first column is for x axis, the scond column is for the y axis, and the third column is for the z axis. The fourth column contains</span>
<span class="sd">                the atoms symbols, and the fifth and the last column has the atomic radius of the atoms.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">atom_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">cart_coords</span>
        <span class="n">list_atomic_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_atomic_radius</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">species</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atom_coord</span><span class="p">)):</span>
            <span class="n">list_atomic_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">symbol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atom_coord</span><span class="p">)):</span>
            <span class="n">list_atomic_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">atomic_radius</span><span class="p">)</span>
        <span class="n">hist_atomic_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_atomic_radius</span><span class="p">))</span>
        <span class="n">atom_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">atom_coord</span><span class="p">,</span> <span class="n">list_atomic_symbols</span><span class="p">,</span> <span class="n">list_atomic_radius</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">atom_coord</span></div>

<div class="viewcode-block" id="Locpot_yair.averaging_along_axis"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.averaging_along_axis">[docs]</a>    <span class="k">def</span> <span class="nf">averaging_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">locpot_vec</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">to_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">to_plot_atoms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">to_plot_widths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">to_plot_heights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">to_plot_cursor_choice</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locpot_vec : np.array, optional. default : None</span>
<span class="sd">                2 Columns arrays for the spatial coordinates and the local potential values.</span>
<span class="sd">        to_plot : bool, optional, default: False</span>
<span class="sd">                A flag to determine whether to plot or not.</span>
<span class="sd">        to_plot_atoms : bool, optional, default: False</span>
<span class="sd">                A flag that represents the choice whether to plot or not another plot of the atoms arrangement in 1D.</span>
<span class="sd">        to_plot_widths : bool, optional, default: False</span>
<span class="sd">                A flag that represents the choice whether to annotate or not the peaks widths of the locpot.</span>
<span class="sd">        to_plot_heights : bool, optional, default: False</span>
<span class="sd">                A flag that represents the choice whether to annotate or not the peaks heights of the locpot.</span>
<span class="sd">        to_plot_cursor_choice : bool, optional, default: False</span>
<span class="sd">                A flag that represents the choice whether to show cursor lines and annotate each click with box.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `numpy.ndarray`, (N,2)</span>
<span class="sd">                It returns a locpot matrix.The first column is the vector that contains the spatial coordinates of system.</span>
<span class="sd">                The second column is the averaged potential along the desires axis.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># This code uses pymatgen for importing vasp relevant outputs.(locpot and contcar)</span>

        <span class="n">font_dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">Users</span><span class="se">\\</span><span class="s1">user</span><span class="se">\\</span><span class="s1">AppData</span><span class="se">\\</span><span class="s1">Local</span><span class="se">\\</span><span class="s1">Programs</span><span class="se">\\</span><span class="s1">Python</span><span class="se">\\</span><span class="s1">Python39</span><span class="se">\\</span><span class="s1">Lib</span><span class="se">\\</span><span class="s1">site-packages</span><span class="se">\\</span><span class="s1">matplotlib</span><span class="se">\\</span><span class="s1">mpl-data</span><span class="se">\\</span><span class="s1">fonts</span><span class="se">\\</span><span class="s1">ttf</span><span class="se">\\</span><span class="s1">advent_Re.ttf&#39;</span>
        <span class="n">fonts</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">findSystemFonts</span><span class="p">(</span><span class="n">fontpaths</span><span class="o">=</span><span class="n">font_dir</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">font</span> <span class="ow">in</span> <span class="n">fonts</span><span class="p">:</span>
            <span class="n">fm</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">font</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;advent&#39;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.unicode_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">locpot_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>

            <span class="c1"># The Locpot contains the electrostatic potential energy</span>

            <span class="c1"># Get the lengths of each coordinates of the 3D matrix of the input locpot:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">xpoints</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">ypoints</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">zpoints</span><span class="p">)])</span>

            <span class="c1"># 3x3 matrix whose rows are the lattice vectors.</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">_matrix</span>

            <span class="c1"># Extracting a, b and c lattice vectors from the lattice pymatgen object</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">lattice</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">lattice</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]))</span>

            <span class="c1"># Calculating the norm for each lattice vector</span>
            <span class="n">anorm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">bnorm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">b</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="n">cnorm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">norm_dic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">anorm</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">bnorm</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">cnorm</span><span class="p">}</span>
            <span class="n">axis_dic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;Z&#39;</span><span class="p">}</span>

            <span class="c1"># Calculate the grid point differnce for each direction.</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">([</span><span class="n">anorm</span><span class="p">,</span> <span class="n">bnorm</span><span class="p">,</span> <span class="n">cnorm</span><span class="p">],</span> <span class="p">[</span><span class="n">size</span><span class="p">])</span>

            <span class="c1"># Creating the desired grid</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">locpot_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">xpoints</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">locpot_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">ypoints</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">locpot_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">zpoints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The axis index should be given as an integer 0:x 1:y 2:z or as a list for 2D &#39;</span>
                                     <span class="s1">&#39;calculation&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span>
                    <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">locpot_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">xpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">ypoints</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span>
                    <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">locpot_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">xpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">zpoints</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span>
                    <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">locpot_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">ypoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">zpoints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The axis index should be supplied as an integer 0:x 1:y 2:z or a list of </span><span class="se">\</span>
<span class="s1">                            two integers of these values&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The axis index should be supplied as an integer 0:x 1:y 2:z or a list of two </span><span class="se">\</span>
<span class="s1">                            integers of these values&#39;</span><span class="p">)</span>

            <span class="c1"># Get atoms position for plotting</span>
            <span class="n">atoms_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atoms_position</span><span class="p">()</span>

            <span class="c1"># pymatgen function for finding the averaged potential along a given axis. the</span>
            <span class="c1"># axis is given by its index : 0=x; 1=y; 2=z</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_2D</span><span class="p">:</span>
            <span class="c1"># integrating over the two axes:</span>
            <span class="c1"># Firstly we tried trapz, but for the numeric errors it was better to just sum over the values.</span>
            <span class="c1"># intgeral_over_x_y = d[0][1]*d[0][0]*np.trapz(np.trapz(locpot_array,axis=1),axis=0)/(bnorm*anorm)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_flip</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_flipped</span><span class="p">:</span>
                <span class="n">to_plot_atoms</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
                <span class="n">temp_axis_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">axis_index_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp_axis_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_axis_index</span><span class="p">))</span> <span class="k">if</span>
                                <span class="ow">not</span> <span class="n">temp_axis_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">]</span>
                <span class="n">intgeral</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">locpot_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                                   <span class="n">norm_dic</span><span class="p">[</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">norm_dic</span><span class="p">[</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c1"># creating the final matrix to be returned</span>
                <span class="n">locpot_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">locpot_grid</span><span class="p">,</span> <span class="n">intgeral</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_flip</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_flipped</span><span class="p">:</span>
                    <span class="n">max_z</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">locpot_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">locpot_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_z</span> <span class="o">-</span> <span class="n">locpot_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">has_flipped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">locpot_mat</span> <span class="o">=</span> <span class="n">locpot_vec</span>
                <span class="n">locpot_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">locpot_mat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">to_plot</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">to_plot_atoms</span> <span class="ow">and</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Just for treating the case for indexing to get a single ax when all the code from beneath is based on this syntext.</span>
                    <span class="n">axs</span> <span class="o">=</span> <span class="p">[</span><span class="n">axs</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">norm_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">],</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;1D Local potential&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;1D Local potential&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Draw below the plot atoms positions</span>
            <span class="c1"># Firstly, we find the species in our system</span>
                <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">atoms_specie</span><span class="p">,</span> <span class="n">atoms_specie_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atoms_pos</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">atomic_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">atoms_pos</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]))</span>
                    <span class="n">relative_atomic_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">atoms_pos</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">atomic_radius</span><span class="p">)</span>
            <span class="c1"># relative_atomic_radius = np.multiply(np.float64(atoms_pos[:,4]),0.25)/np.sum(atomic_radius)</span>
            <span class="c1"># relative_atomic_radius = relative_atomic_radius/np.sum(relative_atomic_radius)</span>

            <span class="c1"># for each specie, we want the draw the atom positions with different color for each atom and different size according to the realtive atomic radius</span>
                    <span class="n">specie</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atoms_specie</span><span class="p">]</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">specie</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">specie</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">specie</span> <span class="o">=</span> <span class="n">temp</span>
                    <span class="n">color_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">]</span>
                    <span class="n">dic_specie</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">dic_color</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specie</span><span class="p">)):</span>
                        <span class="n">dic_specie</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">specie</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="mi">0</span><span class="p">})</span>
                        <span class="n">dic_color</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">specie</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">color_list</span><span class="p">[</span><span class="n">i</span><span class="p">]})</span>

                    <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">atoms_specie</span><span class="p">:</span>
                        <span class="n">list_for_each_atoms_specie_pos</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">list_for_each_atoms_specie_height</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">list_for_each_atomic_radius</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms_pos</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">])):</span>
                            <span class="k">if</span> <span class="n">atoms_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">specie</span><span class="p">:</span>
                                <span class="n">list_for_each_atoms_specie_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">atoms_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">]))</span>
                                <span class="n">list_for_each_atoms_specie_height</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">atoms_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                                <span class="n">list_for_each_atomic_radius</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">relative_atomic_radius</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">to_plot</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">to_plot_atoms</span> <span class="ow">and</span>  <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">list_for_each_atoms_specie_pos</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">list_for_each_atoms_specie_height</span><span class="p">),</span> <span class="n">facecolors</span><span class="o">=</span><span class="n">dic_color</span><span class="p">[</span><span class="n">specie</span><span class="p">],</span>
                               <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">list_for_each_atomic_radius</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">specie</span><span class="p">,</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1">#  axs[1].scatter(np.float64(atoms_pos[:,axis_index]),np.float64(atoms_pos[:,axis_index_2[0]]))</span>
                    <span class="c1">#plt.tick_params(labelcolor=&#39;none&#39;, which=&#39;both&#39;, top=False, bottom=True, left=False, right=False)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> axis in Angstrum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">to_plot_atoms</span> <span class="ow">and</span>  <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Perpendicular grid in Angstrum&#39;</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">labelspacing</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">markerscale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">handletextpad</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                          <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center right&#39;</span><span class="p">)</span>
                        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Electrostatic potential in eV, V(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">]),</span><span class="n">fontsize</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
                        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">handletextpad</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_unit_cell_lattice_parameter</span><span class="p">()</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_unit_cell_lattice_parameter</span><span class="p">()</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_unit_cell_lattice_parameter</span><span class="p">()</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">locpot_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># peaks_minima = find_peaks_minima(x, y, ignore_local_minima = True)</span>
            <span class="c1"># peaks_maxima = find_peaks_maxima(x, y, ignore_local_maxima=True)</span>
            <span class="c1"># peaks = np.append(peaks_minima,peaks_maxima,axis=0)</span>
            <span class="c1"># peaks = peaks[peaks[:, 0].argsort()]</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">to_plot</span><span class="p">:</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">to_plot_cursor_choice</span><span class="p">:</span>
                    <span class="n">annot</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span><span class="mi">40</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                          <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span><span class="n">fc</span><span class="o">=</span><span class="s1">&#39;linen&#39;</span><span class="p">,</span><span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-|&gt;&#39;</span><span class="p">),</span><span class="n">fontsize</span> <span class="o">=</span> <span class="mi">14</span>  <span class="p">)</span>
                    <span class="n">annot</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="c1"># function for storing and showing the clicked values</span>
                    <span class="c1"># coord=[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">Cursor</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">horizOn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vertOn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
                    <span class="k">def</span> <span class="nf">on_click</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
                        <span class="c1"># nonlocal coord</span>
                        <span class="c1"># coord.append((event.xdata,event.ydata))</span>
                        <span class="n">x_val</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">xdata</span>
                        <span class="n">y_val</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span>
                        <span class="n">annot</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_val</span><span class="p">,</span><span class="n">y_val</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                 <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2"> = </span><span class="si">{:.5g}</span><span class="s2"> Ang, local potential = </span><span class="si">{:.3g}</span><span class="s2"> [eV])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">],</span><span class="n">x_val</span><span class="p">,</span><span class="n">y_val</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2"> = </span><span class="si">{:.5g}</span><span class="s2"> Ang, local potential = </span><span class="si">{:.3g}</span><span class="s2"> [eV])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span>
                                                                                             <span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
                            <span class="n">annot</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span>
                            <span class="n">annot</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">pass</span>

                    <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;button_press_event&#39;</span><span class="p">,</span><span class="n">on_click</span><span class="p">)</span>


                <span class="k">if</span> <span class="n">to_plot_heights</span><span class="p">:</span>
                    <span class="n">anotations</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span><span class="mi">10</span><span class="p">)]:</span>
                        <span class="n">anotations</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">count</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{:.3g}</span><span class="s1"> eV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                        <span class="n">count</span> <span class="o">+=</span><span class="mi">10</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span><span class="mi">10</span><span class="p">)]:</span>
                        <span class="n">anotations</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">count</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{:.3g}</span><span class="s1"> eV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">10</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">anotations</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">is_peak_minimum</span><span class="p">(</span><span class="n">peaks</span><span class="p">,[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]):</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                                                    <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">25</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;linen&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span>
                                                    <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">25</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;linen&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;linen&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                                    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                                    <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;linen&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">to_plot_widths</span><span class="p">:</span>
                    <span class="n">allmax</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ignore_local_maxima</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">maxima</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">allmax</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>

                    <span class="n">widths</span><span class="p">,</span><span class="n">width_heights</span><span class="p">,</span><span class="n">left_ips</span><span class="p">,</span> <span class="n">right_ips</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">peak_widths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">maxima</span><span class="p">,</span> <span class="n">rel_height</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="n">max_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">max_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">new_left_ips</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">new_right_ips</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">new_widths</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_ips</span><span class="p">)):</span>
                        <span class="n">new_left_ips</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left_ips</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">max_coord</span><span class="p">)</span><span class="o">/</span><span class="n">max_index</span><span class="p">)</span>
                        <span class="n">new_right_ips</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right_ips</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_coord</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_index</span><span class="p">)</span>
                        <span class="n">new_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">right_ips</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_coord</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_index</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">left_ips</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">max_coord</span><span class="p">)</span><span class="o">/</span><span class="n">max_index</span><span class="p">)</span>
                    <span class="n">anotations</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">new_left_ips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_left_ips</span><span class="p">)</span>
                    <span class="n">new_right_ips</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_right_ips</span><span class="p">)</span>
                    <span class="n">new_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_widths</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_widths</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">new_widths</span><span class="p">),</span><span class="mi">5</span><span class="p">)]):</span>
                        <span class="n">anotations</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">count</span><span class="p">,</span><span class="s1">&#39;</span><span class="si">{:.3g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                        <span class="n">count</span> <span class="o">+=</span><span class="mi">5</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">anotations</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">width_heights</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">new_left_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">new_right_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">xy</span><span class="o">=</span><span class="p">((</span><span class="n">new_left_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="n">new_right_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">width_heights</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span><span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                            <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round4&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span><span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">width_heights</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_left_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_right_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">xy</span><span class="o">=</span><span class="p">((</span><span class="n">new_left_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">new_right_ips</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">width_heights</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span>
                                            <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">boxstyle</span><span class="o">=</span><span class="s1">&#39;round4&#39;</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">ec</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span><span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">([</span><span class="s1">&#39;science&#39;</span><span class="p">,</span> <span class="s1">&#39;notebook&#39;</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                     <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mf">0.135</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mf">0.845</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.30</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.70</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">0.085</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;1D potential along axis </span><span class="si">{}</span><span class="s1">.svg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">]),</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;svg&quot;</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;1D potential along axis </span><span class="si">{}</span><span class="s1">.svg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;svg&quot;</span><span class="p">,</span>
                                <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">locpot_mat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">temp_axis_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">axis_index_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp_axis_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_axis_index</span><span class="p">))</span> <span class="k">if</span>
                            <span class="ow">not</span> <span class="n">temp_axis_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">]</span>
            <span class="n">integral</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">locpot_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm_dic</span><span class="p">[</span><span class="n">axis_index_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            <span class="n">locpot_mat</span> <span class="o">=</span> <span class="n">locpot_grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">locpot_mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">integral</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">to_plot</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">locpot_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">norm_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                <span class="n">locpot_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">norm_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">locpot_mat</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> axis in Angstrum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> axis in Angstrum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;2D Electrostatic potential in eV, V(</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                                  <span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;2D potential along axis </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                       <span class="n">axis_dic</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
            <span class="k">return</span> <span class="n">locpot_mat</span></div>

<div class="viewcode-block" id="Locpot_yair.find_interface"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.find_interface">[docs]</a>    <span class="k">def</span> <span class="nf">find_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : np.array, array_like, optional, default: None</span>
<span class="sd">                It stands for the spatial coordinates array.</span>
<span class="sd">                If not supplied, is calcualted from the instance attribute self.locpot.</span>

<span class="sd">        y : np.array, array_like, optional, default: None</span>
<span class="sd">                The local potential vector.</span>
<span class="sd">                If not supplied, is calcualted from the instance attribute ``self.locpot``.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, float</span>
<span class="sd">                It returns the interface index in the locpot vector, and its z&#39;s position</span>
<span class="sd">                If the system does not contain an interface, it just returns the last spatial grid coordinate position</span>
<span class="sd">                and its corresponded index. -&gt; [index,position] ==&gt; [len(z)-1,z[-1]]</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">diff2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">index_flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">max_flag</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">zz</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">peaks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="n">zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">peaks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">num_of_peaks</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">num_of_peaks</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iterations</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">peaks_step_2</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="n">peaks_step_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">zz</span> <span class="o">=</span> <span class="n">peaks_step_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">zzz</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">diff2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">zzz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zzz</span><span class="p">,</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">num_of_peaks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff2</span><span class="p">)</span>
                <span class="n">iterations</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">num_of_peaks</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">peaks_step_2</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">zzz</span><span class="p">,</span> <span class="n">diff2</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_step_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">diff</span> <span class="o">=</span> <span class="n">peaks_step_2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                                <span class="n">zz</span> <span class="o">=</span> <span class="n">peaks_step_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                                <span class="n">zzz</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="n">diff2</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                            <span class="n">zzz</span> <span class="o">=</span> <span class="n">zz</span>
                            <span class="n">diff2</span> <span class="o">=</span> <span class="n">diff</span>
                            <span class="k">break</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                 <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; It did not find an interface, instead you will treat the end of the locpot as an interface&#39;</span><span class="p">)</span>
                 <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff2</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diff2</span><span class="p">))</span>
                <span class="n">z_interface</span> <span class="o">=</span> <span class="n">zzz</span><span class="p">[</span><span class="n">max_value</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">z_interface</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Locpot_yair.approximately"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.approximately">[docs]</a>    <span class="k">def</span> <span class="nf">approximately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compare_to</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compare_to : int/float</span>
<span class="sd">                The value we wish to compare to.</span>
<span class="sd">        *args : int/float/array_like</span>
<span class="sd">                The value\s we wish to compare to.</span>
<span class="sd">        tol : int/float, optional, default: 5</span>
<span class="sd">                In precents. The tolerance level we wish to apply. The default value is set to 5% tolerance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">                It returns `True` or `False` whether the input value is in the proxmity range of the tolerance</span>
<span class="sd">                with respect to the the values supplied.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tol</span> <span class="o">/=</span> <span class="mi">100</span>
        <span class="n">tol_p</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">tol_m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tol</span>
        <span class="n">compare_to</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">compare_to</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">compare_to</span> <span class="o">&lt;=</span> <span class="mf">0.1</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">compare_to</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>
                    <span class="n">compare_to</span> <span class="o">=</span> <span class="mf">0.1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mf">0.1</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">compare_to</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">*</span> <span class="n">tol_m</span> <span class="o">&lt;=</span> <span class="n">compare_to</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">tol_p</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">flag</span></div>

<div class="viewcode-block" id="Locpot_yair.find_unit_cell_lattice_parameter"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.find_unit_cell_lattice_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">find_unit_cell_lattice_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_axis_rel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        is_axis_rel : bool, optional, default: True</span>
<span class="sd">                A flag that tells if the class object attribute - `axis_index`</span>
<span class="sd">                is the relevant to return the appropriate lattice parameter in that direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">                The relevant lattice parameter.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">lattice_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span>
        <span class="k">if</span> <span class="n">is_axis_rel</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_2D</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not programmed for 2D potentail calc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lattice_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lattice_parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lattice_parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis index should be 0:x 1:y 2:z&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lattice_parameters</span></div>

<div class="viewcode-block" id="Locpot_yair.find_all_permutations"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.find_all_permutations">[docs]</a>    <span class="k">def</span> <span class="nf">find_all_permutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">materials_list_strings</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        materials_list_strings : array_like,type: str</span>
<span class="sd">                The input of the species names / materials names whithin the system</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        res : array_like,type: str</span>
<span class="sd">                It returns all the combinations of materials or species that can be found.</span>
<span class="sd">                It suppose to locate locpot files of the bulk materials in the current working directory</span>
<span class="sd">                to be loaded into the interface Locpot object.</span>
<span class="sd">                It meant to answer cases where we have a material constructed of several species such as</span>
<span class="sd">                GaAs\ AlN\ and so on..</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">materials_list_strings</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">materials_list_strings</span><span class="p">,</span> <span class="n">idx</span><span class="p">)))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ele</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Locpot_yair.set_locpot_bulk_materials"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.set_locpot_bulk_materials">[docs]</a>    <span class="k">def</span> <span class="nf">set_locpot_bulk_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulk_material</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        **Loading the bulk materials&#39; locpots of the two materials involved in the interface system.**</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bulk_material : bool, optional, default: False</span>
<span class="sd">                Can be given for skipping to load another level of bulk material.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># if not bulk_material and len(self.locpot_bulk_materials) &lt; 2 and self.Has_interface:</span>
        <span class="c1">#     interface_ind, interface = self.find_interface()</span>
        <span class="c1">#     species = self.locpot.structure.symbol_set</span>
        <span class="c1">#     atoms_positions = self.get_atoms_position()</span>
        <span class="c1">#     symbols_vector_main_axis = atoms_positions[:, 3]</span>
        <span class="c1">#     system_bottom = np.sort(np.float64(atoms_positions[:, 2]))[0]</span>
        <span class="c1">#     system_upper = np.sort(np.float64(atoms_positions[:, 2]))[-1]</span>
        <span class="c1">#     first_half_symbols_vector = symbols_vector_main_axis[[np.float64(atoms_positions[:, 2]) &lt; interface - 2.5][0] *</span>
        <span class="c1">#                                      [np.float64(atoms_positions[:, 2]) &gt; system_bottom + 2.5][0]]</span>
        <span class="c1">#     sec_half_symbols_vector = symbols_vector_main_axis[[np.float64(atoms_positions[:, 2]) &gt; interface + 2.5][0] *</span>
        <span class="c1">#                                      [np.float64(atoms_positions[:, 2]) &lt; system_upper - 2.5][0]]</span>
        <span class="c1">#     first_material = np.unique(first_half_symbols_vector)</span>
        <span class="c1">#     first_material_string = Locpot_yair.find_all_permutations(first_material)</span>
        <span class="c1">#     second_material = np.unique(sec_half_symbols_vector)</span>
        <span class="c1">#     second_material_string = Locpot_yair.find_all_permutations(second_material)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bulk_material</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_locpot_path</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Locpot</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span></div>


        <span class="c1">#     path = &quot;../../LOCPOTS_For_Git/LOCPOT_&quot;</span>
        <span class="c1">#     for i in first_material_string:</span>
        <span class="c1">#         locpot_path = os.path.join(path, str(i)).replace(&quot;\\&quot;, &quot;&quot;)</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             self.locpot_bulk_materials.append(Locpot.from_file(locpot_path))</span>
        <span class="c1">#         except:</span>
        <span class="c1">#             pass</span>
        <span class="c1">#     for i in second_material_string:</span>
        <span class="c1">#         locpot_path = os.path.join(path, str(i)).replace(&quot;\\&quot;, &quot;&quot;)</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             self.locpot_bulk_materials.append(Locpot.from_file(locpot_path))</span>
        <span class="c1">#         except:</span>
        <span class="c1">#             pass</span>
        <span class="c1"># else:</span>
        <span class="c1">#     pass</span>

<div class="viewcode-block" id="Locpot_yair.set_axis_index"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.set_axis_index">[docs]</a>    <span class="k">def</span> <span class="nf">set_axis_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_ind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        axis_ind : int, {0: x, 1: y, 2: z}, optional, default: None</span>
<span class="sd">                    The axis index we desire to update our object attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">                *Just set up a new axis index property of the object instance.*</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">axis_ind</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis_index</span> <span class="o">=</span> <span class="n">axis_ind</span></div>

<div class="viewcode-block" id="Locpot_yair.set_is_2D"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.set_is_2D">[docs]</a>    <span class="k">def</span> <span class="nf">set_is_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is2d</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        is2d : bool, optional, default: False</span>
<span class="sd">                A flag to determine whether the calculation should be performed in 2D.</span>
<span class="sd">                This is an editing method for the class object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_2D</span> <span class="o">=</span> <span class="n">is2d</span></div>

<div class="viewcode-block" id="Locpot_yair.find_position_to_insert"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.find_position_to_insert">[docs]</a>    <span class="k">def</span> <span class="nf">find_position_to_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Gets Locpot object. Using the interface and bulk materials&#39; locpots.</span>
<span class="sd">        Look for the best place to insert the bulk locpot into the interface</span>
<span class="sd">        system locpot.</span>
<span class="sd">        Can be supplied in advance zz - spatial coordinates vector, and vv - local potential vector,</span>
<span class="sd">        to be referenced as the main vector to be searched to position to insert.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zz : np.array, optional, default: None</span>
<span class="sd">                If not supplied, the default is taken from `self.locpot_vec[:, 0]` attribute of `Locpot_yair` instance.</span>
<span class="sd">                Vector of the spatial grid. (spatial coordinates)</span>
<span class="sd">        vv : np.array, optional, default: None</span>
<span class="sd">                If not supplied, the default is taken from `self.locpot_vec[:, 1]` attribute of `Locpot_yair` instance.</span>
<span class="sd">                Vector of the local potential.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, int</span>
<span class="sd">                It returns the position, and its corresponding index in the interface locpot interface. Regarding both the left side materials</span>
<span class="sd">                and the right side material. These 2 arrays of the form [,,] -&gt; where [start_ind, finish_ind, minima_position, max_R_sqrd]</span>
<span class="sd">                If we don&#39;t have an interface, it returns the last index,position of the spatial grid vector.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># input verification</span>
        <span class="c1">#..................................................</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span> <span class="o">=</span> <span class="n">to_2_column_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">zz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># ..................................................</span>

        <span class="c1"># Checks if the system contains an interface</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span><span class="p">:</span>
            <span class="c1"># if it does has an interface:</span>
            <span class="n">interface_ind</span><span class="p">,</span><span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_interface</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span><span class="n">vv</span><span class="p">)</span>

            <span class="c1"># first bulk material == from the left of the interface</span>
            <span class="n">z_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">v_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">z_left_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_left</span><span class="p">,</span> <span class="n">v_left</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_left_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_left</span><span class="p">,</span> <span class="n">v_left</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># second bulk material == from the right of the interface</span>
            <span class="n">z_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">v_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">z_right_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_right</span><span class="p">,</span> <span class="n">v_right</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_right_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_right</span><span class="p">,</span> <span class="n">v_right</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Getting the first bulk material locpot from the class attribute.</span>
            <span class="n">first_bulk_material</span> <span class="o">=</span> <span class="n">Locpot_yair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">z_first_bulk</span> <span class="o">=</span> <span class="n">first_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_first_bulk</span> <span class="o">=</span> <span class="n">first_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_first_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span> <span class="n">z_first_bulk</span> <span class="p">,</span> <span class="n">v_first_bulk</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_first_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_first_bulk</span><span class="p">,</span> <span class="n">v_first_bulk</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Getting the second bulk material locpot from the class attribute.</span>
            <span class="n">sec_bulk_material</span> <span class="o">=</span> <span class="n">Locpot_yair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z_sec_bulk</span> <span class="o">=</span> <span class="n">sec_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_sec_bulk</span> <span class="o">=</span> <span class="n">sec_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_sec_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_sec_bulk</span><span class="p">,</span> <span class="n">v_sec_bulk</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_sec_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_sec_bulk</span><span class="p">,</span> <span class="n">v_sec_bulk</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># finds the vertical shifts between the system local potential and its bulk materials local potentials.</span>
            <span class="n">shift_left</span><span class="p">,</span> <span class="n">shift_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_locpot_shift</span><span class="p">()</span>

            <span class="c1"># Fixing the local potential values by adding or substracting the relevant shift.</span>
            <span class="n">v_first_bulk</span> <span class="o">=</span> <span class="n">v_first_bulk</span> <span class="o">-</span> <span class="n">shift_left</span>
            <span class="n">v_sec_bulk</span> <span class="o">=</span> <span class="n">v_sec_bulk</span> <span class="o">-</span> <span class="n">shift_right</span>


            <span class="n">index_minimas_left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">length_first_bulk_material</span> <span class="o">=</span> <span class="n">z_first_bulk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_first_bulk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">minima_position</span> <span class="o">=</span> <span class="n">z_left_minimas</span><span class="p">[</span><span class="n">index_minimas_left</span><span class="p">]</span>
            <span class="n">max_R_sqrd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indices_left</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The loop iterates via the minima points and jumps at each iteration by the length of the bulk material</span>
            <span class="c1"># locpot. It then compares the cut range of the system locpot with the bulk material locpot.</span>
            <span class="c1"># The comparison test is R_sqrd. Then Taking the section the yield the highest R_sqrd and returning the</span>
            <span class="c1"># indedice where it starts from and end at. The starting position will be considered as the position</span>
            <span class="c1"># to insert at.</span>

            <span class="k">while</span> <span class="n">minima_position</span> <span class="o">+</span> <span class="n">length_first_bulk_material</span> <span class="o">&lt;=</span> <span class="n">z_left_minimas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">index_minimas_left</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">z_left_minimas</span><span class="p">):</span>

                <span class="n">start_index</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span><span class="p">,</span><span class="n">z_left</span><span class="p">)</span>
                <span class="n">finish_index</span><span class="p">,</span> <span class="n">finish_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span> <span class="o">+</span> <span class="n">length_first_bulk_material</span><span class="p">,</span><span class="n">z_left</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">finish_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_left</span><span class="p">):</span>
                    <span class="n">temp_z</span><span class="p">,</span> <span class="n">temp_v</span> <span class="o">=</span> <span class="n">z_left</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">finish_index</span><span class="p">],</span> <span class="n">v_left</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">finish_index</span><span class="p">]</span>
                    <span class="n">temp_z</span><span class="p">,</span> <span class="n">temp_v</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_first_bulk</span><span class="p">),</span><span class="n">temp_z</span><span class="p">,</span> <span class="n">temp_v</span><span class="p">)</span>
                    <span class="n">temp_R_sqrd</span> <span class="o">=</span> <span class="n">r_sqrd</span><span class="p">(</span><span class="n">v_first_bulk</span><span class="p">,</span> <span class="n">temp_v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">temp_R_sqrd</span> <span class="o">&gt;</span> <span class="n">max_R_sqrd</span><span class="p">:</span>
                        <span class="n">max_R_sqrd</span> <span class="o">=</span> <span class="n">temp_R_sqrd</span>
                        <span class="n">start_index</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span><span class="p">,</span> <span class="n">zz</span><span class="p">)</span>
                        <span class="n">finish_index</span><span class="p">,</span> <span class="n">finish_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span> <span class="o">+</span> <span class="n">length_first_bulk_material</span><span class="p">,</span>
                                                                               <span class="n">zz</span><span class="p">)</span>
                        <span class="n">indices_left</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_index</span><span class="p">,</span> <span class="n">finish_index</span><span class="p">,</span> <span class="n">minima_position</span><span class="p">,</span><span class="n">max_R_sqrd</span><span class="p">,</span><span class="n">temp_z</span><span class="p">,</span><span class="n">temp_v</span><span class="p">,</span><span class="n">z_first_bulk</span><span class="o">+</span><span class="n">start_pos</span><span class="p">,</span><span class="n">v_first_bulk</span> <span class="p">]</span>
                    <span class="n">index_minimas_left</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">minima_position</span> <span class="o">=</span> <span class="n">z_left_minimas</span><span class="p">[</span><span class="n">index_minimas_left</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">index_minimas_right</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">length_sec_bulk_material</span> <span class="o">=</span> <span class="n">z_sec_bulk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_sec_bulk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">minima_position</span> <span class="o">=</span> <span class="n">z_right_minimas</span><span class="p">[</span><span class="n">index_minimas_right</span><span class="p">]</span>
            <span class="n">max_R_sqrd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indices_right</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The above loop treats the left hand side of the system. (from the left of the interface)</span>
            <span class="c1"># This loop treats the right hand side of the system in the same manner.</span>

            <span class="k">while</span> <span class="n">minima_position</span> <span class="o">+</span> <span class="n">length_sec_bulk_material</span> <span class="o">&lt;=</span> <span class="n">z_right_minimas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">index_minimas_right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">z_right_minimas</span><span class="p">):</span>

                <span class="n">start_index</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span><span class="p">,</span><span class="n">z_right</span><span class="p">)</span>
                <span class="n">finish_index</span><span class="p">,</span> <span class="n">finish_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span> <span class="o">+</span> <span class="n">length_sec_bulk_material</span><span class="p">,</span><span class="n">z_right</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">finish_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">zz</span><span class="p">):</span>
                    <span class="n">temp_z</span><span class="p">,</span> <span class="n">temp_v</span> <span class="o">=</span> <span class="n">z_right</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">finish_index</span><span class="p">],</span> <span class="n">v_right</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">finish_index</span><span class="p">]</span>
                    <span class="n">temp_z</span><span class="p">,</span> <span class="n">temp_v</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_sec_bulk</span><span class="p">),</span><span class="n">temp_z</span><span class="p">,</span> <span class="n">temp_v</span><span class="p">)</span>
                    <span class="n">temp_R_sqrd</span> <span class="o">=</span> <span class="n">r_sqrd</span><span class="p">(</span><span class="n">v_sec_bulk</span><span class="p">,</span> <span class="n">temp_v</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">temp_R_sqrd</span> <span class="o">&gt;</span> <span class="n">max_R_sqrd</span><span class="p">:</span>
                        <span class="n">max_R_sqrd</span> <span class="o">=</span> <span class="n">temp_R_sqrd</span>
                        <span class="n">start_index</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span><span class="p">,</span> <span class="n">zz</span><span class="p">)</span>
                        <span class="n">finish_index</span><span class="p">,</span> <span class="n">finish_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_position</span> <span class="o">+</span> <span class="n">length_sec_bulk_material</span><span class="p">,</span>
                                                                               <span class="n">zz</span><span class="p">)</span>
                        <span class="n">indices_right</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_index</span><span class="p">,</span> <span class="n">finish_index</span><span class="p">,</span> <span class="n">minima_position</span><span class="p">,</span> <span class="n">max_R_sqrd</span><span class="p">,</span> <span class="n">temp_z</span><span class="p">,</span><span class="n">temp_v</span><span class="p">,</span><span class="n">z_sec_bulk</span><span class="o">+</span><span class="n">start_pos</span><span class="p">,</span><span class="n">v_sec_bulk</span><span class="p">]</span>
                    <span class="n">index_minimas_right</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">minima_position</span> <span class="o">=</span> <span class="n">z_right_minimas</span><span class="p">[</span><span class="n">index_minimas_right</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="k">return</span> <span class="n">indices_left</span><span class="p">,</span> <span class="n">indices_right</span>

        <span class="c1"># Namely, we don&#39;t have an interface in our system, so the position to insert will be</span>
        <span class="c1"># at the end of the system. It returns the index of the last position in the spatial grid vector</span>
        <span class="c1"># and the actual position at the grid,</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">zz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Locpot_yair.set_locpot_vec"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.set_locpot_vec">[docs]</a>    <span class="k">def</span> <span class="nf">set_locpot_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A method aims to initialize Locpot vector of the Locpot object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Input verifiaction</span>
        <span class="c1"># ...........................................................</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">averaging_along_axis</span><span class="p">()</span>
            <span class="n">lat_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_unit_cell_lattice_parameter</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">lat_par</span>
        <span class="c1"># ...........................................................</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">1</span>

        <span class="c1"># This loop guaruntee that the length of the system will be at least at the length of 20*spatial_spacing (dx)</span>
        <span class="k">while</span>  <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">dx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">multiply_z_v_vecs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">multi</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Locpot_yair.elongate_locpot"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.elongate_locpot">[docs]</a>    <span class="k">def</span> <span class="nf">elongate_locpot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multi_left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">multi_right</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">manual</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pos_to_insert</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">multi_manual</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z_to_insert_manual</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">locpot_vec</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">return_left_increment</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">return_right_increment</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multi_left : int, optional, default: 1</span>
<span class="sd">                It determines how many times to multiply the repeated locpot that will be inserted.</span>
<span class="sd">        multi_right : int, optional, default: 1</span>
<span class="sd">                It determines how many times to multiply the repeated locpot that will be inserted.</span>
<span class="sd">        manual : bool, optional, default: False</span>
<span class="sd">                This is a flag the tells if we are going to treat the elongation manually or automatically.</span>
<span class="sd">                If it is set to ``True``, we should supply more arguments as desribed in the next lines.</span>
<span class="sd">        pos_to_insert : float, optional, default: None</span>
<span class="sd">                If `manual =` ``True``, then it must be supplied. It determines where to insert the multiplied repeated locpot.</span>
<span class="sd">                It is a position in the spatial grid.</span>
<span class="sd">        multi_manual : int, optional, default: None</span>
<span class="sd">                If `manual =` ``True``, then it must be supplied. It determines how many times to</span>
<span class="sd">                multiply the repeated locpot that will be inserted manually.</span>
<span class="sd">        z_to_insert_manual : np.array, optional, default: None</span>
<span class="sd">                If `manual =` ``True``, then it must be supplied. The manully inserted spatial coordinates vector.</span>
<span class="sd">        v_to_insert_manual : np.array, optional, default: None</span>
<span class="sd">                If  `manual =` ``True``, then it must be supplied. The manully inserted local potential vector.</span>
<span class="sd">        locpot_vec : `numpy.ndarray`, (N,2), optional, default: None</span>
<span class="sd">                It is not necessarily goes with the &#39;manual&#39; option. It just gives more flexibilty whether the</span>
<span class="sd">                elongation will be held on the class instance locpot attribute, or on an external locpot vector supplied as an argument. This is a two-column vector,</span>
<span class="sd">                the first column is for the spatial coordinates and the second column is for the local potential.</span>
<span class="sd">        return_left_increment : bool, optional, default : False</span>
<span class="sd">                If it is set to ``True``, the difference between the original and the elongated local potential vectors will be returned together with the reference point.</span>
<span class="sd">        return_right_increment : bool, optional, default : False</span>
<span class="sd">                If it is set to ``True``, the difference between the original and the elongated local potential vectors will be returned together with the reference point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z_Locp, v_Locp : np.array, np.array</span>
<span class="sd">                The new elongated spatial grid vector, the new elongated local potential vector.</span>
<span class="sd">        z_Locp, v_Locp, delta, ref point : np.array, np.array, float, float</span>
<span class="sd">                If return_right_increment or return_right_increment == ``True``</span>
<span class="sd">                It returns also difference between the original and the elongated local potential vectors will be returned together with the reference point, if</span>
<span class="sd">                it was specified to return those.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># if locpot_vec is supplied as an argument, all the changes will take ation uppon it.</span>
        <span class="c1"># Otherwise they will affect only the locpot attribute of the class instance.</span>
        <span class="n">delta_length_right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delta_length_left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delta_length_general</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_Locp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v_Locp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_Locp</span> <span class="o">=</span> <span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v_Locp</span> <span class="o">=</span> <span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">z_Locp</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">)</span>
        <span class="n">v_Locp</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v_Locp</span><span class="p">)</span>
        <span class="n">len_original_temp_right</span> <span class="o">=</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_Locp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">len_original_temp_left</span> <span class="o">=</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_Locp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">len_original_temp_general</span> <span class="o">=</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_Locp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># if we wish all the procedure to occure automatically with the class feature and attributes:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">manual</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span><span class="p">:</span>
            <span class="n">Locp_first_bulk_material</span> <span class="o">=</span> <span class="n">Locpot_yair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">is_bulk_material</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Locp_sec_bulk_material</span> <span class="o">=</span> <span class="n">Locpot_yair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">is_bulk_material</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">z_first_bulk_material</span> <span class="o">=</span> <span class="n">Locp_first_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v_first_bulk_material</span> <span class="o">=</span> <span class="n">Locp_first_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_first_bulk_material</span><span class="p">,</span> <span class="n">v_first_bulk_material</span> <span class="o">=</span> <span class="n">multiply_z_v_vecs</span><span class="p">(</span><span class="n">z_first_bulk_material</span><span class="p">,</span> <span class="n">v_first_bulk_material</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">multi_left</span><span class="p">)</span>

            <span class="n">z_sec_bulk_material</span> <span class="o">=</span> <span class="n">Locp_sec_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v_sec_bulk_material</span> <span class="o">=</span> <span class="n">Locp_sec_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_sec_bulk_material</span><span class="p">,</span> <span class="n">v_sec_bulk_material</span> <span class="o">=</span> <span class="n">multiply_z_v_vecs</span><span class="p">(</span><span class="n">z_sec_bulk_material</span><span class="p">,</span> <span class="n">v_sec_bulk_material</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">multi_right</span><span class="p">)</span>

            <span class="n">left_shift</span><span class="p">,</span> <span class="n">right_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_locpot_shift</span><span class="p">()</span>
            <span class="n">indices_left</span><span class="p">,</span> <span class="n">indices_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_position_to_insert</span><span class="p">()</span>
            <span class="n">z_locp_length_original</span> <span class="o">=</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># if loading the instance system locpot, and its bulk material locpot, and then, search for good match</span>
            <span class="c1"># of the bulk material locpot on the whole system locpot. When it satisfies the condition of the R_sqrd to be</span>
            <span class="c1"># greater than 0.85, it inserted the multiplied bulk material locpot at the position if found.</span>
            <span class="c1"># It does it both for the right and the left side of the interface system.</span>
            <span class="k">if</span> <span class="n">indices_left</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.85</span><span class="p">:</span>
                <span class="n">ind_to_insert</span><span class="p">,</span><span class="n">pos_to_insert</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">indices_left</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">z_Locp</span><span class="p">)</span>
                <span class="n">z_locp_length_original</span> <span class="o">=</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span> <span class="o">=</span> <span class="n">insert_potential_into_position</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">,</span><span class="n">ind_to_insert</span><span class="p">,</span><span class="n">z_first_bulk_material</span><span class="p">,</span><span class="n">v_first_bulk_material</span><span class="o">-</span><span class="n">left_shift</span><span class="p">)</span>
                <span class="n">delta_length_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_Locp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">len_original_temp_left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;There was no a good fit between any peaks in the interface locpot and the  left bulk material locpot&#39;</span><span class="p">)</span>
            <span class="n">indices_right</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices_right</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_locp_length_original</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indices_right</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.85</span><span class="p">:</span>
                <span class="n">ind_to_insert</span><span class="p">,</span> <span class="n">pos_to_insert</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">indices_right</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">z_Locp</span><span class="p">)</span>
                <span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span> <span class="o">=</span> <span class="n">insert_potential_into_position</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">,</span><span class="n">ind_to_insert</span><span class="p">,</span><span class="n">z_sec_bulk_material</span><span class="p">,</span><span class="n">v_sec_bulk_material</span><span class="o">-</span><span class="n">right_shift</span><span class="p">)</span>
                <span class="n">delta_length_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_Locp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">len_original_temp_left</span> <span class="o">-</span> <span class="n">delta_length_left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;There was no a good fit between any peaks in the interface locpot and the right bulk material locpot&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span> <span class="o">=</span> <span class="n">to_2_column_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_left_increment</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_right_increment</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span><span class="p">,</span><span class="n">delta_length_left</span>
            <span class="k">elif</span> <span class="n">return_right_increment</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_left_increment</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span><span class="p">,</span> <span class="n">delta_length_right</span>
            <span class="k">elif</span> <span class="n">return_right_increment</span> <span class="ow">and</span>  <span class="n">return_left_increment</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span><span class="p">,</span> <span class="n">delta_length_left</span><span class="p">,</span><span class="n">delta_length_right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec_elongated</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos_to_insert</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Please input as argument position in z where to start the elongation. If it is not supplied&#39;</span>
                      <span class="s1">&#39;the default is to elongate from the end of the vector&#39;</span><span class="p">)</span>
                <span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span> <span class="o">=</span> <span class="n">multiply_z_v_vecs</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">,</span> <span class="n">multi</span> <span class="o">=</span> <span class="n">multi_manual</span> <span class="p">)</span>
                <span class="n">pos_to_insert</span> <span class="o">=</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">z_to_insert_manual</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">v_to_insert_manual</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;please provide z and v vectors to insert manually&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Namely, we treat the system manually:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span><span class="p">:</span>
                        <span class="n">ref_point</span> <span class="o">=</span> <span class="n">pos_to_insert</span>
                    <span class="n">z_to_insert_manual</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z_to_insert_manual</span><span class="p">)</span>
                    <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v_to_insert_manual</span><span class="p">)</span>
                    <span class="n">v_to_insert_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_to_insert_manual</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">locp_min_peaks_z</span><span class="p">,</span><span class="n">locp_min_peaks_v</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">,</span><span class="n">v_Locp</span><span class="p">,</span><span class="n">ignore_local_minima</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">locp_min_peaks_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">locp_min_peaks_z</span><span class="p">,</span> <span class="n">locp_min_peaks_v</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">,</span> <span class="n">ignore_local_minima</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">ind</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">pos_to_insert</span><span class="p">,</span> <span class="n">locp_min_peaks_z</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">locp_min_peaks_v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">v_locpot_global_min</span> <span class="o">=</span> <span class="n">locp_min_peaks_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v_locpot_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">locp_min_peaks_v</span><span class="p">[</span><span class="n">ind</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">locp_min_peaks_v</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span><span class="n">locp_min_peaks_v</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="c1"># Taking care of the vertical shifts between the system locpot and the going-to-be inserted locpot.</span>
                    <span class="k">if</span> <span class="n">v_to_insert_global_min</span> <span class="o">&gt;=</span> <span class="n">v_locpot_global_min</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_to_insert_global_min</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_locpot_global_min</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="n">v_to_insert_global_min</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v_to_insert_global_min</span><span class="p">)</span>
                        <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v_to_insert_manual</span><span class="p">)</span>
                        <span class="n">v_shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_to_insert_global_min</span> <span class="o">-</span> <span class="n">v_locpot_global_min</span><span class="p">)</span>
                        <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="n">v_to_insert_manual</span> <span class="o">-</span> <span class="n">v_shift</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_to_insert_global_min</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_locpot_global_min</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
                        <span class="n">v_to_insert_global_min</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">eV2J</span><span class="p">(</span><span class="n">v_to_insert_global_min</span><span class="p">)</span>
                        <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">eV2J</span><span class="p">(</span><span class="n">v_to_insert_manual</span><span class="p">)</span>
                        <span class="n">v_shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_to_insert_global_min</span> <span class="o">-</span> <span class="n">v_locpot_global_min</span><span class="p">)</span>
                        <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="n">v_to_insert_manual</span> <span class="o">-</span> <span class="n">v_shift</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v_shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_to_insert_global_min</span> <span class="o">-</span> <span class="n">v_locpot_global_min</span><span class="p">)</span>
                        <span class="n">v_to_insert_manual</span> <span class="o">=</span> <span class="n">v_to_insert_manual</span> <span class="o">-</span> <span class="n">v_shift</span>

                    <span class="n">ind</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">pos_to_insert</span><span class="p">,</span> <span class="n">z_Locp</span><span class="p">)</span>
                    <span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span> <span class="o">=</span> <span class="n">insert_potential_into_position</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">,</span><span class="n">ind</span><span class="p">,</span><span class="n">z_to_insert_manual</span><span class="p">,</span><span class="n">v_to_insert_manual</span><span class="p">,</span><span class="n">multi</span><span class="o">=</span><span class="n">multi_manual</span> <span class="p">)</span>
                    <span class="n">locpot_vec_elongated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">z_Locp</span><span class="p">,</span> <span class="n">v_Locp</span><span class="p">))</span>
                    <span class="n">locpot_vec_elongated</span> <span class="o">=</span> <span class="n">to_2_column_mat</span><span class="p">(</span><span class="n">locpot_vec_elongated</span><span class="p">)</span>
                    <span class="n">delta_length_general</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_Locp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">len_original_temp_general</span>
                    <span class="k">if</span> <span class="n">return_right_increment</span> <span class="ow">or</span> <span class="n">return_left_increment</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">locpot_vec_elongated</span><span class="p">,</span> <span class="n">delta_length_general</span><span class="p">,</span><span class="n">ref_point</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">locpot_vec_elongated</span><span class="p">,</span> <span class="n">delta_length_general</span><span class="p">,</span> <span class="n">z_Locp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">locpot_vec_elongated</span></div>
<div class="viewcode-block" id="Locpot_yair.find_locpot_shift"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.Locpot_yair.find_locpot_shift">[docs]</a>    <span class="k">def</span> <span class="nf">find_locpot_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">locpot_vec</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bulk_locpot_vec_first</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bulk_locpot_vec_second</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Finds the relative vertical shifts between the materials in the interface system and their corresponding</span>
<span class="sd">        bulk materials locpot.</span>
<span class="sd">        Afterwards, these value have to be substracted from the potential vector</span>
<span class="sd">        of the interface system in order to be inserted in the elongation procedure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If your system does not have an interface, you should supply one of the arguments `bulk_locpot_vec_first` or `bulk_locpot_vec_second`</span>
<span class="sd">        with a locpot-formed vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        locpot_vec : `numpy.ndarray`, (N,2), optional, default: None</span>
<span class="sd">                This is a two-column vector, the first column is for the spatial coordinates and the second column is for the local potential.</span>
<span class="sd">        bulk_locpot_vec_first : `numpy.ndarray`, (N,2), optional, default: None</span>
<span class="sd">                This is a two-column vector, the first column is for the spatial coordinates and the second column is for the local potential. This locpot matrix</span>
<span class="sd">                should describe the locpot matrix of the first bulk material.</span>
<span class="sd">        bulk_locpot_vec_second : `numpy.ndarray`, (N,2), optional, default: None</span>
<span class="sd">                This is a two-column vector, the first column is for the spatial coordinates and the second column is for the local potential. This locpot matrix</span>
<span class="sd">                should describe the locpot matrix of the second bulk material.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list, [float, float]</span>
<span class="sd">                The relative shifts of both the left and the right side materials.</span>
<span class="sd">                In the form of 2 floats -&gt; [,] -&gt; where [left_shift,right_shift].</span>
<span class="sd">                If the system does not contain an interface, it returns the shift only from the one part that was supplied.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># if locpot_vec can be supplied as an argument, all the changes will take ation uppon it.</span>
        <span class="c1"># Otherwise they will affect only the locpot attribute of the class instance.</span>
        <span class="k">if</span> <span class="n">locpot_vec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zz</span> <span class="o">=</span> <span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">vv</span> <span class="o">=</span> <span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">interface_ind</span><span class="p">,</span> <span class="n">interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_interface</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span>

        <span class="c1"># If our system contains an interface</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Has_interface</span><span class="p">:</span>
            <span class="c1"># Taking care of the left hand side of the interface:</span>
            <span class="n">z_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">v_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">z_left_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_left</span><span class="p">,</span> <span class="n">v_left</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_left_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_left</span><span class="p">,</span> <span class="n">v_left</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">mid_min_left</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_left_minimas</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">tol_range_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_left_minimas</span><span class="p">))))</span>
            <span class="n">v_left_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_left_minimas</span><span class="p">[</span><span class="n">mid_min_left</span> <span class="o">-</span> <span class="n">tol_range_left</span> <span class="p">:</span> <span class="n">mid_min_left</span> <span class="o">+</span> <span class="n">tol_range_left</span><span class="p">])</span>
            <span class="c1"># Taking care of the right hand side of the interface:</span>
            <span class="n">z_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">v_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span> <span class="k">if</span> <span class="n">zz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">interface</span><span class="p">])</span>
            <span class="n">z_right_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_right</span><span class="p">,</span> <span class="n">v_right</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_right_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_right</span><span class="p">,</span> <span class="n">v_right</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">mid_min_right</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_right_minimas</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">tol_range_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_right_minimas</span><span class="p">))))</span>
            <span class="n">v_right_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_right_minimas</span><span class="p">[</span><span class="n">mid_min_right</span> <span class="o">-</span> <span class="n">tol_range_right</span> <span class="p">:</span> <span class="n">mid_min_right</span> <span class="o">+</span> <span class="n">tol_range_right</span><span class="p">])</span>

            <span class="c1"># Loading the bulk-material locpots.</span>
            <span class="k">if</span> <span class="n">bulk_locpot_vec_first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">first_bulk_material</span> <span class="o">=</span> <span class="n">Locpot_yair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You did not succeeded to load the left bulk material locpot. try to handle it manully or fix it instead&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You did not succeeded to load the left bulk material locpot. try to handle it manully or fix it instead&#39;</span><span class="p">)</span>
                <span class="n">z_first_bulk</span> <span class="o">=</span> <span class="n">first_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v_first_bulk</span> <span class="o">=</span> <span class="n">first_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z_first_bulk</span> <span class="o">=</span> <span class="n">bulk_locpot_vec_first</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v_first_bulk</span> <span class="o">=</span> <span class="n">bulk_locpot_vec_first</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_first_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span> <span class="n">z_first_bulk</span> <span class="p">,</span> <span class="n">v_first_bulk</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_first_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_first_bulk</span><span class="p">,</span> <span class="n">v_first_bulk</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">v_first_bulk_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_first_bulk_minimas</span><span class="p">)</span>
            <span class="c1"># Comparison for choosing whether to substract or adding the shift for the local potential.</span>
            <span class="k">if</span> <span class="n">v_first_bulk_global_min</span> <span class="o">&gt;=</span> <span class="n">v_left_global_min</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">v_first_bulk_shift</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_first_bulk_global_min</span> <span class="o">-</span> <span class="n">v_left_global_min</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bulk_locpot_vec_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">sec_bulk_material</span> <span class="o">=</span> <span class="n">Locpot_yair</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_bulk_materials</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You did not succeeded to load the right bulk material locpot. try to handle it manully or fix it instead&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You did not succeeded to load the right bulk material locpot. try to handle it manully or fix it instead&#39;</span><span class="p">)</span>
                <span class="n">z_sec_bulk</span> <span class="o">=</span> <span class="n">sec_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v_sec_bulk</span> <span class="o">=</span> <span class="n">sec_bulk_material</span><span class="o">.</span><span class="n">locpot_vec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z_sec_bulk</span> <span class="o">=</span> <span class="n">bulk_locpot_vec_second</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v_sec_bulk</span> <span class="o">=</span> <span class="n">bulk_locpot_vec_second</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z_sec_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_sec_bulk</span><span class="p">,</span> <span class="n">v_sec_bulk</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">v_sec_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_sec_bulk</span><span class="p">,</span> <span class="n">v_sec_bulk</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">v_sec_bulk_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_sec_bulk_minimas</span><span class="p">)</span>
            <span class="c1"># Comparison for choosing whether to substract or adding the shift for the local potential.</span>
            <span class="k">if</span> <span class="n">v_sec_bulk_global_min</span> <span class="o">&gt;=</span> <span class="n">v_right_global_min</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">v_sec_bulk_shift</span> <span class="o">=</span>  <span class="n">i</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_sec_bulk_global_min</span> <span class="o">-</span> <span class="n">v_right_global_min</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">v_first_bulk_shift</span><span class="p">,</span> <span class="n">v_sec_bulk_shift</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Namely, we does not have an interface in our system</span>
            <span class="k">if</span> <span class="n">bulk_locpot_vec_first</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bulk_locpot_vec_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You should supply at least one locpot in order to find the shifts&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You should supply at least one locpot in order to find the shifts&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bulk_locpot_vec_first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">z_bulk</span> <span class="o">=</span>  <span class="n">bulk_locpot_vec_first</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">v_bulk</span> <span class="o">=</span>  <span class="n">bulk_locpot_vec_first</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">bulk_locpot_vec_second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">z_bulk</span> <span class="o">=</span>  <span class="n">bulk_locpot_vec_second</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">v_bulk</span> <span class="o">=</span>  <span class="n">bulk_locpot_vec_second</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Taking care the bulk-like part of the comparison</span>
                <span class="n">z_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_bulk</span><span class="p">,</span> <span class="n">v_bulk</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v_bulk_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z_bulk</span><span class="p">,</span> <span class="n">v_bulk</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">v_bulk_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v_bulk_minimas</span><span class="p">)</span>
                <span class="c1"># Taking care the system part of the comparison</span>
                <span class="n">z_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">vv</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v_minimas</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="n">vv</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">mid_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_minimas</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">tol_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v_minimas</span><span class="p">))))</span>
                <span class="n">v_global_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                    <span class="n">v_minimas</span><span class="p">[</span><span class="n">mid_min_right</span> <span class="o">-</span> <span class="n">tol_range</span><span class="p">:</span> <span class="n">mid_min</span> <span class="o">+</span> <span class="n">tol_range</span><span class="p">])</span>
                <span class="c1"># Comparison for choosing whether to substract or adding the shift for the local potential.</span>
                <span class="k">if</span> <span class="n">v_bulk_global_min</span> <span class="o">&gt;=</span> <span class="n">v_global_min</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">v_bulk_shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v_bulk_global_min</span> <span class="o">-</span> <span class="n">v_global_min</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">v_bulk_shift</span></div></div>

<div class="viewcode-block" id="find_bulk_like_potential"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.find_bulk_like_potential">[docs]</a><span class="k">def</span> <span class="nf">find_bulk_like_potential</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">interface_position</span><span class="p">,</span> <span class="n">num_of_peaks</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="n">limits</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notice that this is not a class method, it outside the scope of the class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : np.array</span>
<span class="sd">        Should be as the same size as wave_function vector. spatial coordinates vector.</span>
<span class="sd">    v : np.array</span>
<span class="sd">        Should be as the same size as wave_function vector. Local potential vector.</span>
<span class="sd">    interface_position : float</span>
<span class="sd">        The position where the interface is located. If you dont have an interface in your system,</span>
<span class="sd">        just input the `0` or the beginning position of the system.</span>
<span class="sd">    num_of_peaks : int, optional, default: 3</span>
<span class="sd">        If you have an interface, you can choose how many peaks to look for in the system locpot.</span>
<span class="sd">    limits : list\array_like, (float, float), optional, default: None</span>
<span class="sd">        This parameter is an optional for flexibility for chosing the range of where the pick the bulk-like potential.</span>
<span class="sd">        This should be input as a list of two floats, the first one is for the left limit and the second one is for the left limit.</span>
<span class="sd">        Should be given as the same units of the spatial coordainates vector, z.</span>
<span class="sd">    left : bool, optional, default: False</span>
<span class="sd">        A flag that determines whether to look at the left side hand of the system.</span>
<span class="sd">    right : bool, optional, default: False</span>
<span class="sd">        A flag that determines whether to look at the right side hand of the system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, np.array, float</span>
<span class="sd">        The first argument it returns is the spatial grid range where the bulk-like locpot was evaluated.</span>
<span class="sd">        The second argument it returns is the local potential range where the bulk-like locpot was evaluated.</span>
<span class="sd">        The last argument it returns is the start position where the bulk-like locpot was found.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">z_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">interface_position</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">interface_position</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">interface_position</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">left</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">interface_position</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">interface_position</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">interface_position</span>  <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">interface_position</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">interface_position</span><span class="p">]</span>

    <span class="k">elif</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">interface_position</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">interface_position</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You should supply the limits both for the right and the left sides of the chsoen region&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Notice that you supplied the borders in opposite order. I assume that you intend to the opposite order.&#39;</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span><span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span><span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">:</span>
                        <span class="n">limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">limits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You should supply limits that are within the range of the spatial coordinates vector you supllied&#39;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">z_flag</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>



    <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">ignore_local_minima</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">z_peaks</span><span class="p">,</span><span class="n">v_peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="o">.</span><span class="n">T</span>
    <span class="n">mid_peak_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_peaks</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">mid_peak_z</span> <span class="o">=</span> <span class="n">z_peaks</span><span class="p">[</span><span class="n">mid_peak_ind</span><span class="p">]</span>
    <span class="n">mid_peak_v</span> <span class="o">=</span> <span class="n">v_peaks</span><span class="p">[</span><span class="n">mid_peak_ind</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mid_peak_z</span> <span class="o">-</span> <span class="n">z_peaks</span><span class="p">[</span><span class="n">mid_peak_ind</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_of_peaks</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Your system is too small for searching bulk-like local potential trends, the results of this function for searching for bulk like locpot will be the vector itself&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z_start</span> <span class="o">=</span> <span class="n">z_peaks</span><span class="p">[</span><span class="n">mid_peak_ind</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_of_peaks</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span>
    <span class="k">if</span>  <span class="ow">not</span> <span class="n">z_peaks</span><span class="p">[</span><span class="n">mid_peak_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_of_peaks</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span> <span class="o">&lt;=</span> <span class="n">z_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s1">&#39;Your system is too small for searching bulk-like local potential trends, the results of this function for searching for bulk like locpot will be the vector itself&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z_finish</span> <span class="o">=</span> <span class="n">z_peaks</span><span class="p">[</span><span class="n">mid_peak_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_of_peaks</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span>
    <span class="n">z_to_return</span><span class="p">,</span> <span class="n">v_to_return</span> <span class="o">=</span> <span class="n">fix_potential_edges</span><span class="p">(</span><span class="n">z</span><span class="p">[(</span><span class="n">z_start</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_finish</span><span class="p">)],</span><span class="n">v</span><span class="p">[(</span><span class="n">z_start</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_finish</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">[(</span><span class="n">z_start</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_finish</span><span class="p">)],</span> <span class="n">v</span> <span class="p">[(</span><span class="n">z_start</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">z_finish</span><span class="p">)],</span> <span class="n">z_start</span></div>

<div class="viewcode-block" id="find_initial_position_to_initialize_next_to_interface"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.find_initial_position_to_initialize_next_to_interface">[docs]</a><span class="k">def</span> <span class="nf">find_initial_position_to_initialize_next_to_interface</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">pos_inter</span><span class="p">,</span><span class="n">initi_side</span> <span class="o">=</span> <span class="s1">&#39;Left&#39;</span><span class="p">,</span><span class="n">init_position</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : np.array</span>
<span class="sd">        z spatial coordinates vector</span>
<span class="sd">    v : np.array</span>
<span class="sd">        Local potential vector.</span>
<span class="sd">    pos_inter : float</span>
<span class="sd">        The position where we want to initialize our wave-function next to. Usually will be the interface position if</span>
<span class="sd">        our system has one, otherwise - you can choose from where it begins.</span>
<span class="sd">    initi_side : str, {&#39;Left&#39;, &#39;Right&#39;}, optional, default: &#39;Left&#39;</span>
<span class="sd">        Choices are in the bracket. It tells from where we sholud start and look for the next initialization point.</span>
<span class="sd">    init_position : float, optional, default: None</span>
<span class="sd">        In cases when we do not have an interface or want it to be initialized somewhere else.</span>
<span class="sd">        Must accompanied with `pos_inter=0`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z0 : float</span>
<span class="sd">        The initial position where to wave-fucntion is centered at.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">cons</span><span class="o">.</span><span class="n">eV2J</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">pos_inter</span>
    <span class="n">pos_inter</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">pos_inter</span><span class="p">)</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">==</span> <span class="n">pos_inter</span> <span class="c1"># if it False, it means that the position was given in angstrum. So we should return it is angstrum.</span>
    <span class="n">z_peaks_minima</span><span class="p">,</span> <span class="n">v_peaks_minima</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">ignore_local_minima</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">z_peaks_minima</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">z_peaks_minima</span><span class="p">)</span>
    <span class="c1"># If the interface position given here is 0, it means that the initialization can be only from the right side.</span>
    <span class="k">if</span> <span class="n">pos_inter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">initi_side</span> <span class="o">=</span> <span class="s1">&#39;Right&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">init_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_position</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">init_position</span><span class="p">)</span>
            <span class="n">pos_inter</span> <span class="o">=</span> <span class="n">init_position</span>

    <span class="c1"># Initialization from the left side of the initialization position input.</span>
    <span class="k">if</span> <span class="n">initi_side</span> <span class="o">==</span> <span class="s1">&#39;Left&#39;</span><span class="p">:</span>
        <span class="n">z_peaks_minima</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="n">z_peaks_minima</span> <span class="o">&lt;</span> <span class="n">pos_inter</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_peaks_minima</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">z0</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_peaks_minima</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">z0</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z0</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Initialization from the right side of the initialization position input.</span>
    <span class="k">elif</span> <span class="n">initi_side</span> <span class="o">==</span> <span class="s1">&#39;Right&#39;</span><span class="p">:</span>
        <span class="n">z_peaks_minima</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="n">z_peaks_minima</span> <span class="o">&gt;</span> <span class="n">pos_inter</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_peaks_minima</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">z0</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_peaks_minima</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">z0</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z0</span> <span class="o">=</span> <span class="n">z_peaks_minima</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z0</span></div>

<div class="viewcode-block" id="insert_potential_into_position"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.insert_potential_into_position">[docs]</a><span class="k">def</span> <span class="nf">insert_potential_into_position</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">,</span> <span class="n">v_vec_original</span><span class="p">,</span> <span class="n">index_to_insert</span><span class="p">,</span> <span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span><span class="p">,</span>
                                   <span class="n">multi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Very not elegant and complex function.</span>
<span class="sd">    It should be primitive. It does not looking for something, but just gets as input all the needed parameters</span>
<span class="sd">    and insert all the vectors at the right place where it was asked to.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z_vec_original : np.array</span>
<span class="sd">        The coords vector whom we wish to insert the other vector.</span>
<span class="sd">    v_vec_original :  np.array</span>
<span class="sd">        The potential vector whom we wish to insert the other vector.</span>
<span class="sd">    index_to_insert : int</span>
<span class="sd">        The index respect to the z_original_vec where from him and further we</span>
<span class="sd">        are going to insert the desired vector.</span>
<span class="sd">    z_vec_to_insert : np.array</span>
<span class="sd">        The new coords vector we wish insert into the original vector.</span>
<span class="sd">    v_vec_to_insert : np.array</span>
<span class="sd">        The new potential vector we wish insert into the original vector.</span>
<span class="sd">    multi : int, optional, default: 0</span>
<span class="sd">        When the default value is `0`, it means that there is no multiplication.</span>
<span class="sd">        Describes how many time we would like to insert the vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, np.array</span>
<span class="sd">        The first one is the new elongated coords vector. The second one is the new elongated potential vector.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Input verification handling</span>
    <span class="c1"># .......................................................................</span>
    <span class="n">z_vec_original</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span>
    <span class="n">v_vec_original</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">v_vec_original</span><span class="p">)</span>
    <span class="n">z_vec_to_insert</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">z_vec_to_insert</span><span class="p">)</span>
    <span class="n">v_vec_to_insert</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">v_vec_to_insert</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span> <span class="o">=</span> <span class="n">fix_potential_edges</span><span class="p">(</span><span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span> <span class="o">=</span> <span class="n">multiply_z_v_vecs</span><span class="p">(</span><span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span><span class="p">,</span> <span class="n">multi</span><span class="o">=</span><span class="n">multi</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span> <span class="o">=</span> <span class="n">fix_potential_edges</span><span class="p">(</span><span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">z_vec_to_insert</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z_vec_to_insert</span><span class="p">)</span>
    <span class="n">z_vec_original</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span>
    <span class="n">original_grid_density</span> <span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">z_vec_original</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span> <span class="o">=</span> <span class="n">adjust_grid_density</span><span class="p">(</span><span class="n">original_grid_density</span><span class="p">,</span><span class="n">z_vec_to_insert</span><span class="p">,</span> <span class="n">v_vec_to_insert</span><span class="p">)</span>
    <span class="n">insert_to_the_end</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">index_to_insert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_vec_original</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">insert_to_the_end</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># .......................................................................</span>
    <span class="c1"># The normal case, where we don&#39;t insert at the end of the locpot</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">insert_to_the_end</span><span class="p">:</span>
        <span class="c1"># The treatment here is to divide our locpot vector into 2 seperated parts, and handle these two part</span>
        <span class="c1"># separately. In between them we then insert the locpot we wish, and eventually put them all together into</span>
        <span class="c1"># one locpot vector.</span>
        <span class="c1"># The first part before the insertion is the locpot vector from its beginning to the index of insertion.</span>
        <span class="c1"># The second part before the insertion is the locpot vector from one index after the insertion index till the end.</span>
        <span class="n">first_part_z_original</span> <span class="o">=</span> <span class="n">z_vec_original</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_to_insert</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">second_part_z_original</span> <span class="o">=</span> <span class="n">z_vec_original</span><span class="p">[</span><span class="n">index_to_insert</span><span class="o">+</span><span class="mi">2</span><span class="p">::]</span>
        <span class="n">first_part_v_original</span> <span class="o">=</span> <span class="n">v_vec_original</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_to_insert</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">second_part_v_original</span> <span class="o">=</span> <span class="n">v_vec_original</span><span class="p">[</span><span class="n">index_to_insert</span><span class="o">+</span><span class="mi">2</span><span class="p">::]</span>
        <span class="k">def</span> <span class="nf">fix_edges</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">ending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">starting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># It is a very complicated function. It was built to handle the edges issues stem from the</span>
            <span class="c1"># cutting and inserting operations.</span>
            <span class="c1"># It also tries to handle cases where the peaks are in more complicated form with sub-peaks or local minima/maxima.</span>

            <span class="c1"># minima / maxima global and all kind of peaks including local ones.</span>
            <span class="k">if</span> <span class="n">starting</span><span class="p">:</span>
                <span class="n">minima_global</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ignore_local_minima</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">num_of_min</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minima_global</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ignore_local_minima</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">maxima_global</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span><span class="n">ignore_local_maxima</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">minima_tot</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ignore_local_minima</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">maxima_tot</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ignore_local_maxima</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">minima_tot_z</span> <span class="o">=</span> <span class="n">minima_tot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">minima_tot_v</span> <span class="o">=</span> <span class="n">minima_tot</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">maxima_tot_z</span> <span class="o">=</span> <span class="n">maxima_tot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">maxima_tot_v</span> <span class="o">=</span> <span class="n">maxima_tot</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">minima_z</span> <span class="o">=</span> <span class="n">minima_global</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">minima_v</span> <span class="o">=</span> <span class="n">minima_global</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">maxima_z</span> <span class="o">=</span> <span class="n">maxima_global</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">maxima_v</span> <span class="o">=</span> <span class="n">maxima_global</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">minima_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_tot_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">minima_tot_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">z_original_begin</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">z_original_end</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">v_original_begin</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">v_original_end</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">v_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">z_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">z_dz</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">flag_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">z_temp</span> <span class="o">==</span> <span class="n">cons</span><span class="o">.</span><span class="n">m2A</span><span class="p">(</span><span class="n">z_temp</span><span class="p">))</span>
                    <span class="n">flag_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">v_temp</span> <span class="o">==</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v_temp</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># We have to take care of the beginning since it higher</span>
                        <span class="n">height_difference</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">slope_from_right</span> <span class="o">=</span> <span class="n">height_difference</span><span class="o">/</span><span class="n">z_dz</span>
                        <span class="n">ind_temp</span><span class="p">,</span><span class="n">pos_temp</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))::])</span>
                        <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
                        <span class="n">ind_temp</span> <span class="o">=</span> <span class="n">ind_temp</span> <span class="o">+</span> <span class="n">difference</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">dz_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">ind_temp</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">temp_additive_step_z</span> <span class="o">=</span> <span class="n">z_original_end</span>
                        <span class="n">temp_additive_step_v</span> <span class="o">=</span> <span class="n">v_original_begin</span>
                        <span class="n">z_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                        <span class="n">v_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dz_steps</span><span class="p">:</span>
                            <span class="n">temp_additive_step_z</span> <span class="o">+=</span> <span class="n">z_dz</span>
                            <span class="n">temp_additive_step_v</span> <span class="o">-=</span> <span class="p">(</span><span class="n">slope_from_right</span><span class="o">/</span><span class="n">z_dz</span><span class="p">)</span><span class="o">*</span><span class="n">i</span>
                            <span class="n">z_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z_comp</span><span class="p">,</span><span class="n">temp_additive_step_z</span><span class="p">))</span>
                            <span class="n">v_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">temp_additive_step_v</span><span class="p">,</span><span class="n">v_comp</span><span class="p">))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_z</span><span class="p">:</span>
                            <span class="n">z_comp</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">z_comp</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_v</span><span class="p">:</span>
                            <span class="n">v_comp</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">eV2J</span><span class="p">(</span><span class="n">v_comp</span><span class="p">)</span>
                        <span class="n">v_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v_comp</span><span class="p">,</span><span class="n">v_temp</span><span class="p">))</span>
                        <span class="n">z_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z_temp</span><span class="p">,</span><span class="n">z_comp</span><span class="p">))</span>
                        <span class="n">z_temp</span><span class="p">,</span><span class="n">v_temp</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_temp</span><span class="p">),</span><span class="n">z_temp</span><span class="p">,</span><span class="n">v_temp</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># We have to take care of the ending since it higher</span>
                        <span class="n">height_difference</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">J2eV</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">slope_from_left</span> <span class="o">=</span> <span class="n">height_difference</span><span class="o">/</span><span class="n">z_dz</span>
                        <span class="n">ind_temp</span><span class="p">,</span><span class="n">pos_temp</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">v</span><span class="p">[::</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))])</span>
                        <span class="n">difference</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>
                        <span class="n">dz_steps</span> <span class="o">=</span> <span class="n">ind_temp</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">temp_additive_step_z</span> <span class="o">=</span> <span class="n">z_original_end</span>
                        <span class="n">temp_additive_step_v</span> <span class="o">=</span> <span class="n">v_original_end</span>
                        <span class="n">z_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                        <span class="n">v_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dz_steps</span><span class="p">:</span>
                            <span class="n">temp_additive_step_z</span> <span class="o">+=</span> <span class="n">z_dz</span>
                            <span class="n">temp_additive_step_v</span> <span class="o">-=</span> <span class="p">(</span><span class="n">slope_from_left</span><span class="o">/</span><span class="n">z_dz</span><span class="p">)</span><span class="o">*</span><span class="n">i</span>
                            <span class="n">z_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z_comp</span><span class="p">,</span><span class="n">temp_additive_step_z</span><span class="p">))</span>
                            <span class="n">v_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v_comp</span><span class="p">,</span><span class="n">temp_additive_step_v</span><span class="p">))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_z</span><span class="p">:</span>
                            <span class="n">z_comp</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">A2m</span><span class="p">(</span><span class="n">z_comp</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_v</span><span class="p">:</span>
                            <span class="n">v_comp</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="n">eV2J</span><span class="p">(</span><span class="n">v_comp</span><span class="p">)</span>
                        <span class="n">v_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v_temp</span><span class="p">,</span><span class="n">v_comp</span><span class="p">))</span>
                        <span class="n">z_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">z_temp</span><span class="p">,</span><span class="n">z_comp</span><span class="p">))</span>
                        <span class="n">z_temp</span><span class="p">,</span><span class="n">v_temp</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_temp</span><span class="p">),</span><span class="n">z_temp</span><span class="p">,</span><span class="n">v_temp</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">z_temp</span><span class="p">,</span><span class="n">v_temp</span>
            <span class="c1"># each time we treat each part of the locpot. This section relates to the ending, namely - to the part from the insertion index to</span>
            <span class="c1"># the end of the locpot vector.</span>
            <span class="k">if</span> <span class="n">ending</span><span class="p">:</span>
                <span class="c1"># First we find the positions of the minima and maxima points when starting from the last maxima point of the whole locpot.</span>
                <span class="c1"># It will will search from the end a minima-maxima pair, but global points like these, and then it</span>
                <span class="c1"># would cut the range that in between them. Then it will be able to paste this cut-sub-vector at the region of the insertion for fixing its the edges.</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">maxima_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">prominence</span><span class="o">=</span><span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">num_of_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">is_max</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
                <span class="n">tot_last_maxima</span> <span class="o">=</span> <span class="n">maxima_tot_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">index_tot_last_maxima</span><span class="p">,</span> <span class="n">tot_last_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">tot_last_maxima</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
                <span class="n">last_maxima_global</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">index_last_maxima_global</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">minima_before_last_maxima</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">index_minima_before_last_maxima</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ending_vector_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">index_minima_before_last_maxima</span><span class="p">:</span><span class="n">index_last_maxima_global</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">inde</span><span class="o">=</span><span class="mi">1</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ending_vector_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">inde</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">maxima_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">inde</span><span class="p">],</span>
                                                       <span class="n">prominence</span><span class="o">=</span><span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">num_of_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">is_max</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="n">tot_last_maxima</span> <span class="o">=</span> <span class="n">maxima_tot_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">index_tot_last_maxima</span><span class="p">,</span> <span class="n">tot_last_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">tot_last_maxima</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                    <span class="n">last_maxima_global</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">index_last_maxima_global</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">minima_before_last_maxima</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">index_minima_before_last_maxima</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ending_vector_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">index_minima_before_last_maxima</span><span class="p">:</span><span class="n">index_last_maxima_global</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">inde</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ending_vector_z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Check Your peaks detection&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tot_last_maxima</span> <span class="o">&gt;</span> <span class="n">last_maxima_global</span><span class="p">:</span>
                    <span class="n">ending_vector_z</span> <span class="o">=</span> <span class="n">ending_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ending_vector_z</span> <span class="o">+</span> <span class="n">tot_last_maxima</span>
                    <span class="n">ending_vector_z</span> <span class="o">=</span> <span class="n">ending_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ending_vector_z</span> <span class="o">=</span> <span class="n">ending_vector_z</span> <span class="o">+</span> <span class="n">ending_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ending_vector_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ending_vector_v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">index_minima_before_last_maxima</span><span class="p">:</span><span class="n">index_last_maxima_global</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ending_vector_v</span> <span class="o">=</span> <span class="n">ending_vector_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tot_last_maxima</span> <span class="o">&gt;</span> <span class="n">last_maxima_global</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">index_tot_last_maxima</span><span class="p">::])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">index_tot_last_maxima</span><span class="p">::])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">index_last_maxima_global</span><span class="p">::])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">index_last_maxima_global</span><span class="p">::])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">ending_vector_z</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ending_vector_v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">starting</span><span class="p">:</span>
                <span class="c1"># The same here. First we find the positions of the maxima and minima points when starting from the first maxima point of the whole locpot.</span>
                <span class="c1"># It will will search from the beginning a maxima-minima pair, but global points like these, and then it</span>
                <span class="c1"># would cut the range that in between them. Then it will be able to paste this cut-sub-vector at the region of the insertion for fixing its the edges.</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">maxima_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">tot_first_maxima</span> <span class="o">=</span> <span class="n">maxima_tot_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">index_tot_first_maxima</span><span class="p">,</span> <span class="n">tot_first_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">tot_first_maxima</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
                <span class="n">first_maxima</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">index_first_maxima</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">first_minima_after</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">index_first_minima_after</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">starting_vector_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">index_first_maxima</span><span class="p">:</span><span class="n">index_first_minima_after</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tot_first_maxima</span> <span class="o">&lt;=</span>  <span class="n">first_maxima</span><span class="p">:</span>
                    <span class="n">starting_vector_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">starting_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">starting_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">starting_vector_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">first_minima_after</span> <span class="o">-</span> <span class="n">tot_first_maxima</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">starting_vector_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">starting_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">starting_vector_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">+</span> <span class="n">starting_vector_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">starting_vector_v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">index_first_maxima</span><span class="p">:</span><span class="n">index_first_minima_after</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">starting_vector_v</span> <span class="o">=</span> <span class="n">starting_vector_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tot_first_maxima</span> <span class="o">&lt;</span> <span class="n">first_maxima</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_tot_first_maxima</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_tot_first_maxima</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_first_maxima</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index_first_maxima</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_vector_z</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_vector_v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span>

        <span class="n">first_part_z_original</span><span class="p">,</span> <span class="n">first_part_v_original</span> <span class="o">=</span> <span class="n">fix_edges</span><span class="p">(</span><span class="n">first_part_z_original</span><span class="p">,</span> <span class="n">first_part_v_original</span><span class="p">,</span> <span class="n">ending</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">second_part_z_original</span><span class="p">,</span> <span class="n">second_part_v_original</span> <span class="o">=</span> <span class="n">fix_edges</span><span class="p">(</span><span class="n">second_part_z_original</span><span class="p">,</span> <span class="n">second_part_v_original</span><span class="p">,</span> <span class="n">starting</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">second_part_z_original</span> <span class="o">=</span> <span class="n">second_part_z_original</span> <span class="o">+</span>  <span class="n">z_vec_to_insert</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_vec_to_insert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_z_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_part_z_original</span><span class="p">,</span><span class="n">z_vec_to_insert</span><span class="p">)</span>
        <span class="n">new_z_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_z_vec</span><span class="p">,</span><span class="n">second_part_z_original</span> <span class="p">)</span>
        <span class="n">new_z_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">z_vec_original</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">z_vec_to_insert</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_vec_to_insert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="n">z_vec_original</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">new_z_vec</span><span class="p">))</span>
        <span class="n">new_v_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_part_v_original</span><span class="p">,</span><span class="n">v_vec_to_insert</span><span class="p">)</span>
        <span class="n">new_v_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_v_vec</span><span class="p">,</span><span class="n">second_part_v_original</span> <span class="p">)</span>

    <span class="c1">#  Namely - the case when we inserting to the end</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_z_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">,</span> <span class="n">z_vec_to_insert</span><span class="p">)</span>
        <span class="n">new_z_vec</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):]</span> <span class="o">=</span> <span class="n">new_z_vec</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):]</span> <span class="o">+</span> <span class="n">z_vec_original</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_v_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_vec_original</span><span class="p">,</span> <span class="n">v_vec_to_insert</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_z_vec</span><span class="p">),</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_v_vec</span><span class="p">)</span></div>



<div class="viewcode-block" id="fix_potential_edges"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.fix_potential_edges">[docs]</a><span class="k">def</span> <span class="nf">fix_potential_edges</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : np.array</span>
<span class="sd">        Represents the spatial coords vector.</span>
<span class="sd">    v : np.array</span>
<span class="sd">        Represnts the v local potential vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_z : np.array</span>
<span class="sd">        The new z coordinates with matching number of samples with respect with</span>
<span class="sd">        the fixed potential vector.</span>
<span class="sd">    new_v : np.array</span>
<span class="sd">        The new v potential vector after its edges were fixed to be well suitable</span>
<span class="sd">        to be stiched.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Let&#39;s define the form of the first and the last peak</span>
    <span class="c1"># These are the arrays for all the peaks (minimu, and maximum) for both local and global.</span>
    <span class="c1"># tot - means global and local. global - will be only global, local - will be only local</span>
    <span class="k">def</span> <span class="nf">fix_density</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">new_v</span><span class="p">):</span>
        <span class="n">N_fix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_v</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">diff_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_z_end</span> <span class="o">=</span> <span class="n">max_z</span> <span class="o">+</span> <span class="n">N_fix</span> <span class="o">*</span> <span class="n">diff_z</span>
        <span class="n">N_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_v</span><span class="p">))</span>
        <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_z_end</span><span class="p">,</span> <span class="n">N_new</span><span class="p">)</span>
        <span class="n">new_z</span><span class="p">,</span> <span class="n">new_v</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="n">N_new</span><span class="p">,</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_z</span><span class="p">,</span> <span class="n">new_v</span>

    <span class="n">N_original</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">diff_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">minima_tot</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">maxima_tot</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">original_z</span><span class="p">,</span><span class="n">original_v</span> <span class="o">=</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span> <span class="c1"># for debugging</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minima_tot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_tot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span>
    <span class="n">minima_z_tot</span>  <span class="o">=</span> <span class="n">minima_tot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">minima_v_tot</span> <span class="o">=</span> <span class="n">minima_tot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">maxima_z_tot</span> <span class="o">=</span> <span class="n">maxima_tot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">maxima_v_tot</span> <span class="o">=</span> <span class="n">maxima_tot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">promin</span> <span class="o">=</span> <span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">num_of_min</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">minima_global</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ignore_local_minima</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">prominence</span><span class="o">=</span><span class="n">promin</span><span class="p">)</span>
    <span class="n">maxima_global</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ignore_local_maxima</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minima_global</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_global</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span>
    <span class="n">minima_z_global</span>  <span class="o">=</span> <span class="n">minima_global</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">minima_v_global</span> <span class="o">=</span> <span class="n">minima_global</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">maxima_z_global</span> <span class="o">=</span> <span class="n">maxima_global</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">maxima_v_global</span> <span class="o">=</span> <span class="n">maxima_global</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minima_z_global</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">15</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_z_global</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">v</span>
    <span class="n">minima_z_local</span> <span class="o">=</span>  <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minima_z_tot</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">minima_z_global</span><span class="p">]</span>
    <span class="n">minima_v_local</span> <span class="o">=</span>  <span class="p">[</span> <span class="n">minima_v_tot</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">minima_z_tot</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">minima_z_global</span><span class="p">]</span>
    <span class="n">maxima_z_local</span> <span class="o">=</span>  <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">maxima_z_tot</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">maxima_z_global</span><span class="p">]</span>
    <span class="n">maxima_v_local</span> <span class="o">=</span>  <span class="p">[</span> <span class="n">maxima_v_tot</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">maxima_z_global</span><span class="p">]</span>

    <span class="n">main_peak_is_minima</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">main_peak_is_maxima</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">simple_peak</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Checking for if the peak is a simple type of peak (sinusidual peak)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima_z_global</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">minima_z_tot</span><span class="p">))</span><span class="o">&lt;=</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima_z_global</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">))</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">simple_peak</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">elif</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>  <span class="n">minima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>  <span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>  <span class="n">minima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">minima_z_tot</span> <span class="o">=</span> <span class="n">minima_z_tot</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>  <span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">maxima_z_tot</span> <span class="o">=</span> <span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">simple_peak</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="c1"># The beginning of the vector is closer to a maximum point</span>
        <span class="n">main_peak_is_maxima</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">simple_peak</span><span class="p">:</span>
    <span class="c1"># The beginning of the vector is closer to a minimum point</span>
        <span class="n">main_peak_is_minima</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">main_peak_is_maxima</span><span class="p">:</span>
        <span class="p">(</span><span class="n">ind_maxima_first</span><span class="p">,</span> <span class="n">pos_maxima_first</span><span class="p">),</span>  <span class="p">(</span><span class="n">ind_minima_first</span><span class="p">,</span> <span class="n">pos_minima_first</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">minima_z_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ind_minima_sec</span><span class="p">,</span> <span class="n">pos_minima_sec</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_maxima_sec</span><span class="p">,</span> <span class="n">pos_maxima_sec</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">minima_z_global</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ind_first_maxima</span><span class="p">,</span><span class="n">pos_first_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span> <span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_to_be_inserted</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
        <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_to_be_inserted</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

        <span class="n">ind_last_maxima</span><span class="p">,</span><span class="n">pos_last_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">ind_maxima_first</span><span class="p">,</span> <span class="n">pos_maxima_first</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_minima_first</span><span class="p">,</span> <span class="n">pos_minima_first</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">minima_z_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">prominence</span><span class="o">=</span><span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">num_of_min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">is_max</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
            <span class="p">(</span><span class="n">ind_minima_sec</span><span class="p">,</span> <span class="n">pos_minima_sec</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_maxima_sec</span><span class="p">,</span> <span class="n">pos_maxima_sec</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span><span class="n">minima_z_global</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ind_first_maxima</span><span class="p">,</span> <span class="n">pos_first_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span>
                <span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_to_be_inserted</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_to_be_inserted</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="p">(</span><span class="n">ind_maxima_first</span><span class="p">,</span> <span class="n">pos_maxima_first</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_minima_first</span><span class="p">,</span> <span class="n">pos_minima_first</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">minima_z_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">prominence</span><span class="o">=</span><span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span><span class="n">num_of_min</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">is_max</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="p">(</span><span class="n">ind_minima_sec</span><span class="p">,</span> <span class="n">pos_minima_sec</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_maxima_sec</span><span class="p">,</span> <span class="n">pos_maxima_sec</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span><span class="n">minima_z_global</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ind_first_maxima</span><span class="p">,</span> <span class="n">pos_first_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">)</span>
                <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_to_be_inserted</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_to_be_inserted</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">ind_maxima_first</span><span class="p">,</span> <span class="n">pos_maxima_first</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_minima_first</span><span class="p">,</span> <span class="n">pos_minima_first</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">minima_z_global</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">prominence</span><span class="o">=</span><span class="n">get_prominence</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">num_of_min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">is_max</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
                    <span class="p">(</span><span class="n">ind_minima_sec</span><span class="p">,</span> <span class="n">pos_minima_sec</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_maxima_sec</span><span class="p">,</span> <span class="n">pos_maxima_sec</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">minima_z_global</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ind_first_maxima</span><span class="p">,</span> <span class="n">pos_first_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">)</span>
                    <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_to_be_inserted</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                    <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_maxima_first</span><span class="p">:</span><span class="n">ind_minima_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_to_be_inserted</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You had issue in fixing the edges&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span> <span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">:])</span>
        <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z_to_be_inserted</span><span class="p">)</span>
        <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_minima_sec</span><span class="p">:</span><span class="n">ind_maxima_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">:])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v_to_be_inserted</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">main_peak_is_minima</span><span class="p">:</span>
        <span class="p">(</span><span class="n">ind_minima_first</span><span class="p">,</span> <span class="n">pos_minima_first</span><span class="p">),</span>  <span class="p">(</span><span class="n">ind_maxima_first</span><span class="p">,</span> <span class="n">pos_maxima_first</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">minima_z_global</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ind_maxima_sec</span><span class="p">,</span> <span class="n">pos_maxima_sec</span><span class="p">),</span> <span class="p">(</span><span class="n">ind_minima_sec</span><span class="p">,</span> <span class="n">pos_minima_sec</span><span class="p">)</span> <span class="o">=</span> <span class="n">find_adjacent_minima_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">minima_z_global</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ind_first_minima</span><span class="p">,</span><span class="n">pos_first_minima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_z_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_minima_first</span><span class="p">:</span><span class="n">ind_maxima_first</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind_minima_first</span><span class="p">:</span><span class="n">ind_maxima_first</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span> <span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_minima</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_to_be_inserted</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
        <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_minima_first</span><span class="p">:</span><span class="n">ind_maxima_first</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="n">ind_first_minima</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_to_be_inserted</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

        <span class="n">ind_last_minima</span><span class="p">,</span><span class="n">pos_last_minima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">minima_z_tot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_to_be_inserted</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_sec</span><span class="p">:</span><span class="n">ind_minima_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="n">ind_last_minima</span><span class="p">]</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">ind_maxima_sec</span><span class="p">:</span><span class="n">ind_minima_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">z</span> <span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind_last_minima</span><span class="p">:])</span>
        <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z_to_be_inserted</span><span class="p">)</span>
        <span class="n">v_to_be_inserted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ind_maxima_sec</span><span class="p">:</span><span class="n">ind_minima_sec</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind_last_minima</span><span class="p">:])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v_to_be_inserted</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">simple_peak</span><span class="p">:</span>
        <span class="n">minima</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">maxima</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">z</span><span class="p">,</span><span class="n">v</span>
        <span class="n">minima_z</span>  <span class="o">=</span> <span class="n">minima</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">minima_v</span> <span class="o">=</span> <span class="n">minima</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">maxima_z</span> <span class="o">=</span> <span class="n">maxima</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">maxima_v</span> <span class="o">=</span> <span class="n">maxima</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">first_maxima</span> <span class="o">=</span> <span class="n">maxima_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">first_maxima_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">first_maxima</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">last_maxima</span> <span class="o">=</span> <span class="n">maxima_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">last_maxima_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="k">if</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">last_maxima</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">v_vector_ending</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">last_maxima_index</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_vector_ending</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">first_maxima_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">v_vector_starting</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="n">first_maxima_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="n">last_maxima_index</span><span class="p">],</span> <span class="n">v_vector_starting</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">N_fix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_v</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">diff_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_z_end</span> <span class="o">=</span> <span class="n">max_z</span> <span class="o">+</span> <span class="n">N_fix</span> <span class="o">*</span> <span class="n">diff_z</span>
        <span class="n">N_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_v</span><span class="p">))</span>
        <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_z_end</span><span class="p">,</span> <span class="n">N_new</span><span class="p">)</span>
        <span class="n">new_z</span><span class="p">,</span> <span class="n">new_v</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="n">N_new</span><span class="p">,</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_v</span><span class="p">))</span>

        <span class="n">middle_min_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima_v</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">new_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minima_v</span><span class="p">[</span><span class="n">middle_min_num</span><span class="p">]</span> <span class="ow">or</span> <span class="n">new_v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minima_v</span><span class="p">[</span><span class="n">middle_min_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">min_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">minima_v</span><span class="p">[</span><span class="n">middle_min_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">minima_v</span><span class="p">[</span><span class="n">middle_min_num</span><span class="p">]])</span>
            <span class="n">minima_z</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_v</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">minima_v</span> <span class="o">=</span> <span class="n">find_peaks_minima</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_v</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">maxima_z</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_v</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">maxima_v</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_v</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">ind_min_v</span><span class="p">,</span> <span class="n">pos_min_v</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">min_v</span><span class="p">,</span> <span class="n">new_v</span><span class="p">)</span>
            <span class="n">next_maxima_z</span> <span class="o">=</span> <span class="n">maxima_z</span><span class="p">[</span><span class="n">maxima_z</span> <span class="o">&gt;</span> <span class="n">new_z</span><span class="p">[</span><span class="n">ind_min_v</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">next_maxima_v</span> <span class="o">=</span> <span class="n">maxima_v</span><span class="p">[</span><span class="n">maxima_z</span> <span class="o">&gt;</span> <span class="n">new_z</span><span class="p">[</span><span class="n">ind_min_v</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind_next_maxima</span><span class="p">,</span> <span class="n">pos_next_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">next_maxima_z</span><span class="p">,</span> <span class="n">new_z</span><span class="p">)</span>
            <span class="n">new_v_start_vec</span> <span class="o">=</span> <span class="n">new_v</span><span class="p">[</span><span class="n">ind_min_v</span><span class="p">:</span><span class="n">ind_next_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">new_z_start_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_z</span><span class="p">[</span><span class="n">ind_min_v</span><span class="p">:</span><span class="n">ind_next_maxima</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_z</span><span class="p">[</span><span class="n">ind_min_v</span><span class="p">])</span> <span class="o">+</span> <span class="n">new_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">first_maxima_z_ind</span><span class="p">,</span> <span class="n">first_maxima_z_pos</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_z</span><span class="p">)</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">first_maxima_z_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">first_maxima_z_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_z_start_vec</span><span class="p">,</span><span class="n">new_z</span><span class="p">)</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_v_start_vec</span><span class="p">,</span> <span class="n">new_v</span><span class="p">)</span>

            <span class="n">maxima_z</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_v</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">maxima_v</span> <span class="o">=</span> <span class="n">find_peaks_maxima</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_v</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ind_last_maxima</span><span class="p">,</span> <span class="n">pos_last_maxima</span> <span class="o">=</span> <span class="n">find_closest_value_in_array</span><span class="p">(</span><span class="n">maxima_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">new_z</span><span class="p">)</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">::])</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind_last_maxima</span><span class="p">::])</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_z</span><span class="p">,</span><span class="n">new_z_start_vec</span><span class="o">+</span><span class="n">pos_last_maxima</span><span class="o">-</span><span class="n">new_z_start_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_v</span><span class="p">,</span> <span class="n">new_v_start_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">new_z</span><span class="p">,</span> <span class="n">new_v</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_original</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">N_fix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_original</span>
        <span class="n">new_z_end</span> <span class="o">=</span> <span class="n">max_z</span> <span class="o">+</span> <span class="n">N_fix</span> <span class="o">*</span> <span class="n">diff_z</span>
        <span class="n">N_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">N_fix</span> <span class="o">=</span> <span class="n">N_original</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">new_z_end</span> <span class="o">=</span> <span class="n">max_z</span> <span class="o">-</span> <span class="n">N_fix</span> <span class="o">*</span> <span class="n">diff_z</span>
        <span class="n">N_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_z_end</span><span class="p">,</span> <span class="n">N_new</span><span class="p">)</span>
    <span class="n">new_z</span><span class="p">,</span> <span class="n">new_v</span> <span class="o">=</span> <span class="n">interpolate_pchip</span><span class="p">(</span><span class="n">N_new</span><span class="p">,</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_z</span><span class="p">,</span> <span class="n">new_v</span></div>
<span class="c1"># def fix_potential_edges(z, v):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     z : np.array</span>
<span class="c1">#         Represents the spatial coords vector.</span>
<span class="c1">#     v : np.array</span>
<span class="c1">#         Represnts the v local potential vector.</span>
<span class="c1">#</span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     new_z : np.array</span>
<span class="c1">#         The new z coordinates with matching number of samples with respect with</span>
<span class="c1">#         the fixed potential vector.</span>
<span class="c1">#     new_v : np.array</span>
<span class="c1">#         The new v potential vector after its edges were fixed to be well suitable</span>
<span class="c1">#         to be stiched.</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     minima = find_peaks_minima(z, v)</span>
<span class="c1">#     maxima = find_peaks_maxima(z, v)</span>
<span class="c1">#     if len(minima[:,0]) &lt;1 or len(maxima[:,0]) &lt;1:</span>
<span class="c1">#         return z,v</span>
<span class="c1">#     minima_z  = minima[:, 0]</span>
<span class="c1">#     minima_v = minima[:, 1]</span>
<span class="c1">#     maxima_z = maxima[:, 0]</span>
<span class="c1">#     maxima_v = maxima[:, 1]</span>
<span class="c1">#     first_maxima = maxima_z[0]</span>
<span class="c1">#     first_maxima_index = np.int64([i for i in range(0, len(z)) if z[i] == first_maxima][0])</span>
<span class="c1">#     last_maxima = maxima_z[-1]</span>
<span class="c1">#     last_maxima_index = np.int64([i for i in range(0, len(z)) if z[i] == last_maxima][0])</span>
<span class="c1">#     if np.abs(v[-1]) &gt; np.abs(v[0]):</span>
<span class="c1">#</span>
<span class="c1">#         v_vector_ending = v[last_maxima_index:][::-1]</span>
<span class="c1">#         new_v = np.append(v_vector_ending, v[first_maxima_index + 1:])</span>
<span class="c1">#     elif np.abs(v[-1]) &lt; np.abs(v[0]):</span>
<span class="c1">#         v_vector_starting = v[:first_maxima_index + 1][::-1]</span>
<span class="c1">#         new_v = np.append(v[:last_maxima_index], v_vector_starting)</span>
<span class="c1">#     else:</span>
<span class="c1">#         new_v = v</span>
<span class="c1">#     N_fix = len(new_v) - len(v)</span>
<span class="c1">#     diff_z = np.diff(z)[0]</span>
<span class="c1">#     max_z = z[-1]</span>
<span class="c1">#     new_z_end = max_z + N_fix * diff_z</span>
<span class="c1">#     N_new = np.int64(len(new_v))</span>
<span class="c1">#     new_z = np.linspace(z[0], new_z_end, N_new)</span>
<span class="c1">#     new_z, new_v = interpolate_pchip(N_new, to_1D_vec(new_z), to_1D_vec(new_v))</span>
<span class="c1">#</span>
<span class="c1">#     middle_min_num = np.int64(np.round(len(minima_v) / 2))</span>
<span class="c1">#     if new_v[0] &gt; minima_v[middle_min_num] or new_v[0] &gt; minima_v[middle_min_num - 1]:</span>
<span class="c1">#         min_v = np.min([minima_v[middle_min_num - 1], minima_v[middle_min_num]])</span>
<span class="c1">#         minima_z = find_peaks_minima(new_z,new_v)[:, 0]</span>
<span class="c1">#         minima_v = find_peaks_minima(new_z,new_v)[:, 1]</span>
<span class="c1">#         maxima_z = find_peaks_maxima(new_z,new_v)[:, 0]</span>
<span class="c1">#         maxima_v = find_peaks_maxima(new_z,new_v)[:, 1]</span>
<span class="c1">#</span>
<span class="c1">#         ind_min_v, pos_min_v = find_closest_value_in_array(min_v, new_v)</span>
<span class="c1">#         next_maxima_z = maxima_z[maxima_z &gt; new_z[ind_min_v]][0]</span>
<span class="c1">#         next_maxima_v = maxima_v[maxima_z &gt; new_z[ind_min_v]][0]</span>
<span class="c1">#         ind_next_maxima, pos_next_maxima = find_closest_value_in_array(next_maxima_z, new_z)</span>
<span class="c1">#         new_v_start_vec = new_v[ind_min_v:ind_next_maxima + 1]</span>
<span class="c1">#         new_z_start_vec = np.abs(new_z[ind_min_v:ind_next_maxima + 1] - new_z[ind_min_v]) + new_z[0]</span>
<span class="c1">#         first_maxima_z_ind, first_maxima_z_pos = find_closest_value_in_array(maxima_z[0], new_z)</span>
<span class="c1">#         new_z = np.delete(new_z,np.s_[0:first_maxima_z_ind+1])</span>
<span class="c1">#         new_v = np.delete(new_v, np.s_[0:first_maxima_z_ind+1])</span>
<span class="c1">#         new_z = np.append(new_z_start_vec,new_z)</span>
<span class="c1">#         new_v = np.append(new_v_start_vec, new_v)</span>
<span class="c1">#</span>
<span class="c1">#         maxima_z = find_peaks_maxima(new_z,new_v)[:, 0]</span>
<span class="c1">#         maxima_v = find_peaks_maxima(new_z,new_v)[:, 1]</span>
<span class="c1">#         ind_last_maxima, pos_last_maxima = find_closest_value_in_array(maxima_z[-1],new_z)</span>
<span class="c1">#         new_z = np.delete(new_z,np.s_[ind_last_maxima::])</span>
<span class="c1">#         new_v = np.delete(new_v, np.s_[ind_last_maxima::])</span>
<span class="c1">#         new_z = np.append(new_z,new_z_start_vec+pos_last_maxima-new_z_start_vec[0])</span>
<span class="c1">#         new_v = np.append(new_v, new_v_start_vec[-1::-1])</span>
<span class="c1">#</span>
<span class="c1">#     return new_z, new_v</span>


<div class="viewcode-block" id="multiply_z_v_vecs"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.multiply_z_v_vecs">[docs]</a><span class="k">def</span> <span class="nf">multiply_z_v_vecs</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">,</span> <span class="n">v_vec_original</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z_vec_original : np.array</span>
<span class="sd">        The spatial coordinates vector whom we wish to multiply.</span>
<span class="sd">    v_vec_original :  np.array</span>
<span class="sd">        The potential vector whom we wish to multiply.</span>
<span class="sd">    multi : int</span>
<span class="sd">        Describes how many time we would like to multiply the vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array, np.array</span>
<span class="sd">        The first array is the new multiplied spatial coordinates vector. The second array is the new multiplied local potential vector.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">multi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">multi</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">z_vec_original</span><span class="p">,</span> <span class="n">v_vec_original</span> <span class="o">=</span> <span class="n">fix_potential_edges</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">,</span> <span class="n">v_vec_original</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">z_vec_original</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span>
    <span class="n">v_vec_original</span> <span class="o">=</span> <span class="n">to_1D_vec</span><span class="p">(</span><span class="n">v_vec_original</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">v_vec_original</span><span class="p">),</span> <span class="s1">&#39;size of the coords vec must be the same as the potential vector.&#39;</span>
    <span class="n">z_max_initial</span> <span class="o">=</span> <span class="n">z_vec_original</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z_min_initial</span> <span class="o">=</span> <span class="n">z_vec_original</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">z_vec_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">z_vec_original</span><span class="p">)</span>
    <span class="n">v_vec_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">v_vec_original</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">multi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">z_max</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">z_max_initial</span>
        <span class="n">z_min</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">z_min_initial</span>
        <span class="n">z_vec_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_vec_new</span><span class="p">,</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span> <span class="o">+</span> <span class="n">z_vec_original</span><span class="p">))</span>
        <span class="n">v_vec_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_vec_new</span><span class="p">,</span> <span class="n">v_vec_original</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z_vec_new</span><span class="p">,</span> <span class="n">v_vec_new</span></div>


<span class="c1"># def fit_sin(zz, vv, N=1):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#     Fit sinusodial potential vector to the input spatial sequence coordinates.</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     zz : 1D np.array</span>
<span class="c1">#         Represents the z coords vector.</span>
<span class="c1">#     vv : 1D np.array</span>
<span class="c1">#         Represents the v potential vector.</span>
<span class="c1">#     N : int.</span>
<span class="c1">#        Number os sinusiduals to approximate. suppose to suit the number of species in the material.</span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#      Dictionary.</span>
<span class="c1">#          Contains fitting data: &quot;amp&quot;, &quot;omega&quot;, &quot;phase&quot;, &quot;offset&quot;, &quot;freq&quot;, &quot;period&quot; and &quot;fitfunc&quot;</span>
<span class="c1">#</span>
<span class="c1">#      1D np.array</span>
<span class="c1">#         1D np.array of the new fitted v potential vector.</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     Number_of_sinus = N</span>
<span class="c1">#     if Number_of_sinus == 1:</span>
<span class="c1">#         zz = np.array(zz)</span>
<span class="c1">#         vv = np.array(vv)</span>
<span class="c1">#         ff = np.fft.fftfreq(len(zz), (zz[1] - zz[0]))  # assume uniform spacing</span>
<span class="c1">#         Fvv = abs(np.fft.fft(vv))</span>
<span class="c1">#         guess_freq = abs(ff[np.argmax(Fvv[1:]) + 1])  # excluding the zero frequency &quot;peak&quot;, which is related to offset</span>
<span class="c1">#         guess_amp = np.std(vv) * 2. ** 0.5</span>
<span class="c1">#         guess_offset = np.mean(vv)</span>
<span class="c1">#         guess = np.array([guess_amp, 2. * np.pi * guess_freq, 0., guess_offset])</span>
<span class="c1">#</span>
<span class="c1">#         def sinfunc(z, A, w, p, c):</span>
<span class="c1">#             return A * np.sin(w * z + p) + c</span>
<span class="c1">#</span>
<span class="c1">#         popt, pcov = curve_fit(sinfunc, zz, vv, p0=guess)</span>
<span class="c1">#         A, w, p, c = popt</span>
<span class="c1">#         f = w / (2. * np.pi)</span>
<span class="c1">#         fitfunc = lambda z: A * np.sin(w * z + p) + c</span>
<span class="c1">#         new_fitted_func = fitfunc(zz)</span>
<span class="c1">#         maximas_new_fitted_func = find_peaks_maxima(zz, new_fitted_func)[:, 1]</span>
<span class="c1">#         maximas_z_original = find_peaks_maxima(zz, vv)[:, 1]</span>
<span class="c1">#         if np.abs(maximas_new_fitted_func[0] - maximas_z_original[0]) &gt; 0.01:</span>
<span class="c1">#             shift = np.abs(maximas_new_fitted_func[0] - maximas_z_original[0])</span>
<span class="c1">#             guess = np.array([guess_amp, 2. * np.pi * guess_freq, 0., guess_offset + shift])</span>
<span class="c1">#             c = c + shift</span>
<span class="c1">#         return {&quot;amp&quot;: A, &quot;omega&quot;: w, &quot;phase&quot;: p, &quot;offset&quot;: c, &quot;freq&quot;: f, &quot;period&quot;: 1. / f, &quot;fitfunc&quot;: fitfunc,</span>
<span class="c1">#                 &quot;maxcov&quot;: np.max(pcov), &quot;rawres&quot;: (guess, popt, pcov)}, fitfunc(zz)</span>
<span class="c1">#     elif Number_of_sinus == 2:</span>
<span class="c1">#         zz = np.array(zz)</span>
<span class="c1">#         vv = np.array(vv)</span>
<span class="c1">#         ff = np.fft.fftfreq(len(zz), (zz[1] - zz[0]))  # assume uniform spacing</span>
<span class="c1">#         Fvv = abs(np.fft.fft(vv))[1:]</span>
<span class="c1">#         f = np.argsort(Fvv[0:np.int64(np.floor(len(Fvv) / 2))])[::-1][:2]</span>
<span class="c1">#         guess_freq_1 = abs(ff[f[0] + 1])  # excluding the zero frequency &quot;peak&quot;, which is related to offset</span>
<span class="c1">#         guess_freq_2 = abs(ff[f[1] + 1])</span>
<span class="c1">#         guess_amp_1 = Fvv[f[0]] / (len(vv) / 2)</span>
<span class="c1">#         guess_amp_2 = Fvv[f[1]] / (len(vv) / 2)</span>
<span class="c1">#         guess_offset = np.mean(vv)</span>
<span class="c1">#         guess = np.array(</span>
<span class="c1">#             [guess_amp_1, guess_amp_2, 2. * np.pi * guess_freq_1, 2. * np.pi * guess_freq_2, 0., 0., guess_offset])</span>
<span class="c1">#</span>
<span class="c1">#         def sinfunc_2(z, A, B, w_1, w_2, p_1, p_2, c):</span>
<span class="c1">#             return A * np.sin(w_1 * z + p_1) + B * np.sin(w_2 * z + p_2) + c</span>
<span class="c1">#</span>
<span class="c1">#         popt, pcov = curve_fit(sinfunc_2, zz, vv, p0=guess, maxfev=5000)</span>
<span class="c1">#         A, B, w_1, w_2, p_1, p_2, c = popt</span>
<span class="c1">#         f = w_1 / (2. * np.pi)</span>
<span class="c1">#         fitfunc_2 = lambda z: A * np.sin(w_1 * z + p_1) + B * np.sin(w_2 * z + p_2) + c</span>
<span class="c1">#         new_fitted_func = fitfunc_2(zz)</span>
<span class="c1">#         maximas_new_fitted_func = find_peaks_maxima(zz, new_fitted_func)[:, 1]</span>
<span class="c1">#         maximas_z_original = find_peaks_maxima(zz, vv)[:, 1]</span>
<span class="c1">#         if np.abs(maximas_new_fitted_func[0] - maximas_z_original[0]) &gt; 0.01:</span>
<span class="c1">#             shift = np.abs(maximas_new_fitted_func[0] - maximas_z_original[0])</span>
<span class="c1">#             guess = np.array(</span>
<span class="c1">#                 [guess_amp_1, guess_amp_2, 2. * np.pi * guess_freq_1, 2. * np.pi * guess_freq_2, 0., 0., guess_offset])</span>
<span class="c1">#             c = c + shift</span>
<span class="c1">#         return {&quot;amp_1&quot;: A, &quot;amp_2&quot;: B, &quot;omega_1&quot;: w_1, &quot;omega_2&quot;: w_2, &quot;phase_1&quot;: p_1, &quot;phase_2&quot;: p_2, &quot;offset&quot;: c,</span>
<span class="c1">#                 &quot;freq&quot;: f, &quot;period&quot;: 1. / f, &quot;fitfunc&quot;: fitfunc_2, &quot;maxcov&quot;: np.max(pcov),</span>
<span class="c1">#                 &quot;rawres&quot;: (guess, popt, pcov)}, fitfunc_2(zz)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def v_is_matching_moving_avg(v_original, v_to_compare):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     v_original : 1D np.array</span>
<span class="c1">#         The potential vector we wish to compare respect to it.</span>
<span class="c1">#     v_to_compare : 1D np.array</span>
<span class="c1">#         The potential vector we wish to compare with. Usually will be the curve fitting result.</span>
<span class="c1">#</span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     flag : Boolean</span>
<span class="c1">#         Checks whether the two potential vectors are similar or not.</span>
<span class="c1">#</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     i = 0</span>
<span class="c1">#     v_original = to_1D_vec(v_original)</span>
<span class="c1">#     v_to_compare = to_1D_vec(v_to_compare)</span>
<span class="c1">#     flag = True</span>
<span class="c1">#     while i &lt; len(v_original) - 5 and flag:</span>
<span class="c1">#         temp_v_original = v_original[i:i + 10]</span>
<span class="c1">#         temp_v_to_compare = v_to_compare[i:i + 10]</span>
<span class="c1">#         moving_avg_v_original = np.average(temp_v_original)</span>
<span class="c1">#         moving_avg_v_to_compare = np.average(temp_v_to_compare)</span>
<span class="c1">#         if np.abs(moving_avg_v_original - moving_avg_v_to_compare) &gt; 0.1:</span>
<span class="c1">#             flag = False</span>
<span class="c1">#         i += 1</span>
<span class="c1">#     return flag</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def fit_sum_of_sines_4(zz, vv):</span>
<span class="c1">#     zz = np.array(zz)</span>
<span class="c1">#     vv = np.array(vv)</span>
<span class="c1">#     ff = np.fft.fftfreq(len(zz), (zz[1] - zz[0]))  # assume uniform spacing</span>
<span class="c1">#     Fvv = abs(np.fft.fft(vv))[1:]</span>
<span class="c1">#     f = np.argsort(Fvv[0:np.int64(np.floor(len(Fvv) / 2))])[::-1][:5]</span>
<span class="c1">#     guess_freq_1 = abs(ff[f[0] + 1])  # excluding the zero frequency &quot;peak&quot;, which is related to offset</span>
<span class="c1">#     guess_freq_2 = abs(ff[f[1] + 1])</span>
<span class="c1">#     guess_freq_3 = abs(ff[f[2] + 1])</span>
<span class="c1">#     guess_freq_4 = abs(ff[f[3] + 1])</span>
<span class="c1">#</span>
<span class="c1">#     guess_amp_1 = Fvv[f[0]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_2 = Fvv[f[1]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_3 = Fvv[f[2]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_4 = Fvv[f[3]] / (len(vv) / 2)</span>
<span class="c1">#</span>
<span class="c1">#     guess_offset = np.mean(vv)</span>
<span class="c1">#</span>
<span class="c1">#     guess = np.array([guess_amp_1, guess_amp_2, guess_amp_3, guess_amp_4,</span>
<span class="c1">#                       2. * np.pi * guess_freq_1, 2. * np.pi * guess_freq_2,</span>
<span class="c1">#                       2. * np.pi * guess_freq_3, 2. * np.pi * guess_freq_4,</span>
<span class="c1">#                       0., 0., 0., 0.,</span>
<span class="c1">#                       guess_offset])</span>
<span class="c1">#</span>
<span class="c1">#     def sinfunc_4(z, A, B, C, D,</span>
<span class="c1">#                   w_1, w_2, w_3, w_4,</span>
<span class="c1">#                   p_1, p_2, p_3, p_4, c):</span>
<span class="c1">#         return (A * np.sin(w_1 * z + p_1) + B * np.sin(w_2 * z + p_2) +</span>
<span class="c1">#                 C * np.sin(w_3 * z + p_3) + D * np.sin(w_4 * z + p_4)</span>
<span class="c1">#                 + c)</span>
<span class="c1">#</span>
<span class="c1">#     popt, pcov = curve_fit(sinfunc_4, zz, vv, p0=guess, maxfev=5000)</span>
<span class="c1">#     A, B, C, D, w_1, w_2, w_3, w_4, p_1, p_2, p_3, p_4, c = popt</span>
<span class="c1">#</span>
<span class="c1">#     fitfunc_4 = lambda z: A * np.sin(w_1 * z + p_1) + B * np.sin(w_2 * z + p_2) + \</span>
<span class="c1">#                           C * np.sin(w_3 * z + p_3) + D * np.sin(w_4 * z + p_4) + c</span>
<span class="c1">#</span>
<span class="c1">#     return popt, fitfunc_4(zz)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def v_is_matching_curve_fitting(z, v_original, v_to_compare):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     z : 1D np.array</span>
<span class="c1">#        Coordinates vector.</span>
<span class="c1">#     v_original : 1D np.array</span>
<span class="c1">#        The potential vector we wish to compare respect to it.</span>
<span class="c1">#     v_to_compare : 1D np.array</span>
<span class="c1">#         The potential vector we wish to compare with. Usually will be the curve fitting result.</span>
<span class="c1">#</span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     flag : Boolean</span>
<span class="c1">#         Checks whether the two potential vectors are similar or not.</span>
<span class="c1">#</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     dic_para_1, new_v_1 = fit_sin(z, v_original)</span>
<span class="c1">#     dic_para_2, new_v_2 = fit_sin(z, v_original, N=2)</span>
<span class="c1">#     popt_3, new_v_3 = fit_sum_of_sines_4(z, v_original)</span>
<span class="c1">#     popt_4, new_v_4 = fit_sum_of_sines_8(z, v_original)</span>
<span class="c1">#</span>
<span class="c1">#     r1 = r_sqrd(v_original, new_v_1)</span>
<span class="c1">#     r2 = r_sqrd(v_original, new_v_2)</span>
<span class="c1">#     r3 = r_sqrd(v_original, new_v_3)</span>
<span class="c1">#     r4 = r_sqrd(v_original, new_v_4)</span>
<span class="c1">#</span>
<span class="c1">#     if np.max(r1, r2, r3, r4) == r1:</span>
<span class="c1">#         original_fit = new_v_1</span>
<span class="c1">#     elif np.max(r1, r2, r3, r4) == r2:</span>
<span class="c1">#         original_fit = new_v_2</span>
<span class="c1">#     elif np.max(r1, r2, r3, r4) == r3:</span>
<span class="c1">#         original_fit = new_v_3</span>
<span class="c1">#     else:</span>
<span class="c1">#         original_fit = new_v_4</span>
<span class="c1">#</span>
<span class="c1">#     dic_para_1, new_v_1 = fit_sin(z, v_to_compare)</span>
<span class="c1">#     dic_para_2, new_v_2 = fit_sin(z, v_to_compare, N=2)</span>
<span class="c1">#     popt_3, new_v_3 = fit_sum_of_sines_4(z, v_to_compare)</span>
<span class="c1">#     popt_4, new_v_4 = fit_sum_of_sines_8(z, v_to_compare)</span>
<span class="c1">#</span>
<span class="c1">#     r1 = r_sqrd(v_original, new_v_1)</span>
<span class="c1">#     r2 = r_sqrd(v_original, new_v_2)</span>
<span class="c1">#     r3 = r_sqrd(v_original, new_v_3)</span>
<span class="c1">#     r4 = r_sqrd(v_original, new_v_4)</span>
<span class="c1">#</span>
<span class="c1">#     if np.max(r1, r2, r3, r4) == r1:</span>
<span class="c1">#         to_compare_fit = new_v_1</span>
<span class="c1">#     elif np.max(r1, r2, r3, r4) == r2:</span>
<span class="c1">#         to_compare_fit = new_v_2</span>
<span class="c1">#     elif np.max(r1, r2, r3, r4) == r3:</span>
<span class="c1">#         to_compare_fit = new_v_3</span>
<span class="c1">#     else:</span>
<span class="c1">#         to_compare_fit = new_v_4</span>
<span class="c1">#</span>
<span class="c1">#     return r_sqrd(original_fit, to_compare_fit) &gt; 0.995</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def fit_sum_of_sines_8(zz, vv):</span>
<span class="c1">#     zz = np.array(zz)</span>
<span class="c1">#     vv = np.array(vv)</span>
<span class="c1">#     ff = np.fft.fftfreq(len(zz), (zz[1] - zz[0]))  # assume uniform spacing</span>
<span class="c1">#     Fvv = abs(np.fft.fft(vv))[1:]</span>
<span class="c1">#     f = np.argsort(Fvv[0:np.int64(np.floor(len(Fvv) / 2))])[::-1][:9]</span>
<span class="c1">#     guess_freq_1 = abs(ff[f[0] + 1])  # excluding the zero frequency &quot;peak&quot;, which is related to offset</span>
<span class="c1">#     guess_freq_2 = abs(ff[f[1] + 1])</span>
<span class="c1">#     guess_freq_3 = abs(ff[f[2] + 1])</span>
<span class="c1">#     guess_freq_4 = abs(ff[f[3] + 1])</span>
<span class="c1">#     guess_freq_5 = abs(ff[f[4] + 1])</span>
<span class="c1">#     guess_freq_6 = abs(ff[f[5] + 1])</span>
<span class="c1">#     guess_freq_7 = abs(ff[f[6] + 1])</span>
<span class="c1">#     guess_freq_8 = abs(ff[f[7] + 1])</span>
<span class="c1">#</span>
<span class="c1">#     guess_amp_1 = Fvv[f[0]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_2 = Fvv[f[1]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_3 = Fvv[f[2]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_4 = Fvv[f[3]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_5 = Fvv[f[4]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_6 = Fvv[f[5]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_7 = Fvv[f[6]] / (len(vv) / 2)</span>
<span class="c1">#     guess_amp_8 = Fvv[f[7]] / (len(vv) / 2)</span>
<span class="c1">#</span>
<span class="c1">#     guess_offset = np.mean(vv)</span>
<span class="c1">#</span>
<span class="c1">#     guess = np.array([guess_amp_1, guess_amp_2, guess_amp_3, guess_amp_4,</span>
<span class="c1">#                       guess_amp_5, guess_amp_6, guess_amp_7, guess_amp_8,</span>
<span class="c1">#                       2. * np.pi * guess_freq_1, 2. * np.pi * guess_freq_2,</span>
<span class="c1">#                       2. * np.pi * guess_freq_3, 2. * np.pi * guess_freq_4,</span>
<span class="c1">#                       2. * np.pi * guess_freq_5, 2. * np.pi * guess_freq_6,</span>
<span class="c1">#                       2. * np.pi * guess_freq_7, 2. * np.pi * guess_freq_8,</span>
<span class="c1">#                       0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="c1">#                       guess_offset])</span>
<span class="c1">#</span>
<span class="c1">#     def sinfunc_4(z, A, B, C, D, E, F, G, H,</span>
<span class="c1">#                   w_1, w_2, w_3, w_4,</span>
<span class="c1">#                   w_5, w_6, w_7, w_8,</span>
<span class="c1">#                   p_1, p_2, p_3, p_4,</span>
<span class="c1">#                   p_5, p_6, p_7, p_8,</span>
<span class="c1">#                   c):</span>
<span class="c1">#         return (A * np.sin(w_1 * z + p_1) + B * np.sin(w_2 * z + p_2) +</span>
<span class="c1">#                 C * np.sin(w_3 * z + p_3) + D * np.sin(w_4 * z + p_4) +</span>
<span class="c1">#                 E * np.sin(w_5 * z + p_5) + F * np.sin(w_6 * z + p_6) +</span>
<span class="c1">#                 G * np.sin(w_7 * z + p_7) + H * np.sin(w_8 * z + p_8) +</span>
<span class="c1">#                 + c)</span>
<span class="c1">#</span>
<span class="c1">#     popt, pcov = curve_fit(sinfunc_4, zz, vv, p0=guess, maxfev=100000)</span>
<span class="c1">#     A, B, C, D, E, F, G, H, w_1, w_2, w_3, w_4, w_5, w_6, w_7, w_8, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, c = popt</span>
<span class="c1">#</span>
<span class="c1">#     fitfunc_4 = lambda z: (A * np.sin(w_1 * z + p_1) + B * np.sin(w_2 * z + p_2) +</span>
<span class="c1">#                            C * np.sin(w_3 * z + p_3) + D * np.sin(w_4 * z + p_4) +</span>
<span class="c1">#                            E * np.sin(w_5 * z + p_5) + F * np.sin(w_6 * z + p_6) +</span>
<span class="c1">#                            G * np.sin(w_7 * z + p_7) + H * np.sin(w_8 * z + p_8) +</span>
<span class="c1">#                            + c)</span>
<span class="c1">#</span>
<span class="c1">#     return popt, fitfunc_4(zz)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def r_sqrd(v_original, v_fitted):</span>
<span class="c1">#     return 1 - (np.sum(((v_original - v_fitted) ** 2)) / np.sum((v_original - np.mean(v_original)) ** 2))</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def fit_lmfit(zz, vv, N=1):</span>
<span class="c1">#     zz = np.array(zz)</span>
<span class="c1">#     vv = np.array(vv)</span>
<span class="c1">#     ff = np.fft.fftfreq(len(zz), (zz[1] - zz[0]))  # assume uniform spacing</span>
<span class="c1">#     Fvv = abs(np.fft.fft(vv))[1:]</span>
<span class="c1">#     f = np.argsort(Fvv[0:np.int64(np.floor(len(Fvv) / 2))])[::-1][:N + 1]</span>
<span class="c1">#</span>
<span class="c1">#     def sine_1(zz, amp, omega, phase, coeff):</span>
<span class="c1">#         return amp * np.sin(omega * zz + phase) + coeff</span>
<span class="c1">#</span>
<span class="c1">#     def sine(zz, amp, omega, phase):</span>
<span class="c1">#         return amp * np.sin(omega * zz + phase)</span>
<span class="c1">#</span>
<span class="c1">#     mod_1 = Model(sine_1, prefix=&#39;f_1_&#39;)</span>
<span class="c1">#     params = mod_1.make_params(amp=Fvv[f[0]] / (len(vv) / 2), omega=abs(ff[f[0] + 1]), phase=0.0, coeff=np.mean(vv))</span>
<span class="c1">#     params[&#39;f_1_amp&#39;].min = 0.0</span>
<span class="c1">#     mod = mod_1</span>
<span class="c1">#     for i in range(2, N + 1):</span>
<span class="c1">#         mod_temp = Model(sine, prefix=f&#39;f_{i}_&#39;)</span>
<span class="c1">#         param_temp = mod_temp.make_params(amp=Fvv[f[i - 1]] / (len(vv) / 2), omega=abs(ff[f[i - 1] + 1]), phase=0.0)</span>
<span class="c1">#         param_temp[f&#39;f_{i}_amp&#39;].min = 0.0</span>
<span class="c1">#</span>
<span class="c1">#         for j in param_temp.items():</span>
<span class="c1">#             params.add_many(j)</span>
<span class="c1">#         mod = mod_temp + mod</span>
<span class="c1">#     for j in params.keys():</span>
<span class="c1">#         params[j].init_value = None</span>
<span class="c1">#     Model_res = mod.fit(vv, params, zz=zz)</span>
<span class="c1">#     for j in params.keys():</span>
<span class="c1">#         try:</span>
<span class="c1">#             Model_res.params[j].init_value = Model_res.params[j].init_value.value</span>
<span class="c1">#</span>
<span class="c1">#         except:</span>
<span class="c1">#             pass</span>
<span class="c1">#</span>
<span class="c1">#     return Model_res</span>

<div class="viewcode-block" id="is_peak_maximum"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.is_peak_maximum">[docs]</a><span class="k">def</span> <span class="nf">is_peak_maximum</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">peak</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Pay attention - the peak is within the range of the peaks and not at its edges.</span>
<span class="sd">    Otherwise it will raise an index out-of-range error.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : `numpt.ndarray`, (N,2)</span>
<span class="sd">        The first column stands for the spatial poisition of the peaks.</span>
<span class="sd">        The second column is for the height of the peaks.</span>
<span class="sd">    peak : list: [int,float,float]</span>
<span class="sd">        The first argument is for the index of the peak inside the peaks array,</span>
<span class="sd">        The second argument is for the position of the peak. The third argument is for the height of the peak.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        This function checks whether a given peak is a maximum point. (or at least a local maximum).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])])):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">flag</span></div>

<div class="viewcode-block" id="is_peak_minimum"><a class="viewcode-back" href="../Locpot_class.html#Locpot_class.is_peak_minimum">[docs]</a><span class="k">def</span> <span class="nf">is_peak_minimum</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">peak</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Pay attention - the peak is within the range of the peaks and not at its edges.</span>
<span class="sd">    Otherwise it will raise an index out-of-range error.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : `numpt.ndarray`, (N,2)</span>
<span class="sd">        The first column stands for the spatial poisition of the peaks.</span>
<span class="sd">        The second column is for the height of the peaks.</span>
<span class="sd">    peak : list: [int,float,float]</span>
<span class="sd">        The first argument is for the index of the peak inside the peaks array,</span>
<span class="sd">        The second argument is for the position of the peak. The third argument is for the height of the peak.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        This function checks whether a given peak is a minimum point. (or at least a local minimum).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">peaks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])])):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">flag</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, MCT&amp;YairR&amp;NadavS

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>